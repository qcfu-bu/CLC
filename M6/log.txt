checking
t  :=
  let Loc := (Nat : Type) in
  let UL := ((Unit | Loc) : Type) in
  let nil := ((x : UL * Eq(x, (left ()))) : Type) in
  let cons := (fun l => (x : UL * Eq(x, (right l))) : Loc -> Type) in
  let LList :=
    (fun n =>
       iter(fun _ => Loc -> Linear, fun l => [l |-> nil],
         fun n =>
           fun LListn =>
             fun l => (l' : Loc * ([l |-> (cons) l'] * (LListn) l')),
         n) : Nat -> Loc -> Linear)
  in
  let List := (fun n => (l : Loc * ((LList) n) l) : (n : Nat) -> Linear) in
  let Nil :=
    (fun _ => ((alloc) nil) ((left ()), refl((left ()), UL)) : Unit ->
                                                                 (List) 0)
  in
  let Cons :=
    (fun _ =>
       fun ls =>
         let (l1, ls) := ls in
         let (l2, c) :=
           ((alloc) (cons) l1) ((right l1), refl((right l1), UL))
         in (l2, (l1, (c, ls))) : (n : Nat) -> (List) n -> (List) (n +1))
  in let main := (() : Unit) in main
complete
post_ctx := {
}
t  := ()
ty := Unit

desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#228)
| Some (A : U) : (A) -> (option A#229).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#232)
| cons (A : U) : (A) -> ((list A)) -> (list A#233).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#238 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#239 (S n#240)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#246 P#247).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#254 P#255).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#261 B#262).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#266).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Inductive le (n : nat) : (nat) -> U :=
| le_n (n : nat) : (le n#288 n#288)
| le_S (n : nat) : forall (m : nat), ((le n m)) -> (le n#289 (S m#290)).

Definition lt := ((fun m n => (le (S m) n)) : (nat) -> (nat) -> U).

Inductive eq (A : U) (x : A) : (A) -> U :=
| refl (A : U) (x : A) : (eq A#300 x#301 x#301).

Definition eq_trans :=
  ((fun A x y z e1 e2 =>
      match e2 in (eq _ _ y) return (eq A x y) with
      | refl => e1
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (z : A), ((eq A x y)) -> ((eq A y z)) -> (eq A x z)).

Definition eq_sym :=
  ((fun A x y e =>
      match e in (eq _ _ y) return (eq A y x) with
      | refl => refl
      end) :
    forall (A : U),
      forall (x : A), forall (y : A), ((eq A x y)) -> (eq A y x)).

Definition u_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> U), ((eq A x y)) -> ((P) x) -> (P) y).

Definition l_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> L), ((eq A x y)) -> ((P) x) -> (P) y).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Import stdin : stdin_t.

Import stdout : stdout_t.

Definition sender :=
  ((lin ch =>
      match (readline) stdin with
      | (sig_intro msg stdin) =>
        let ch := (send ch) msg in
        let ch := (send ch) msg in
        match close ch with
        | tt => match (close_in) stdin with
                | tt => tt
                end
        end
      end) :
    (channel !(_ : string), !(_ : string), $) -o unit).

Definition Main :=
  match fork (ch : channel !(_ : string), !(_ : string), $) := _main_ in
        (sender) ch
  with
  | (tnsr_intro ch _main_) =>
    match recv ch with
    | (sig_intro msg1 ch) =>
      match recv ch with
      | (sig_intro msg2 ch) =>
        let stdout := ((printline) stdout) ((cat) msg1) "\n" in
        let stdout := ((printline) stdout) ((cat) msg2) "\n" in
        match close ch with
        | tt => match (close_out) stdout with
                | tt => _main_
                end
        end
      end
    end
  end.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#2526)
| Some (A : U) : (A) -> (option A#2527).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#2530)
| cons (A : U) : (A) -> ((list A)) -> (list A#2531).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#2536 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#2537 (S n#2538)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#2544 P#2545).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#2552 P#2553).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#2559 B#2560).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#2564).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Inductive le (n : nat) : (nat) -> U :=
| le_n (n : nat) : (le n#2586 n#2586)
| le_S (n : nat) : forall (m : nat), ((le n m)) -> (le n#2587 (S m#2588)).

Definition lt := ((fun m n => (le (S m) n)) : (nat) -> (nat) -> U).

Inductive eq (A : U) (x : A) : (A) -> U :=
| refl (A : U) (x : A) : (eq A#2598 x#2599 x#2599).

Definition eq_trans :=
  ((fun A x y z e1 e2 =>
      match e2 in (eq _ _ y) return (eq A x y) with
      | refl => e1
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (z : A), ((eq A x y)) -> ((eq A y z)) -> (eq A x z)).

Definition eq_sym :=
  ((fun A x y e =>
      match e in (eq _ _ y) return (eq A y x) with
      | refl => refl
      end) :
    forall (A : U),
      forall (x : A), forall (y : A), ((eq A x y)) -> (eq A y x)).

Definition u_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> U), ((eq A x y)) -> ((P) x) -> (P) y).

Definition l_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> L), ((eq A x y)) -> ((P) x) -> (P) y).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Import stdin : stdin_t.

Import stdout : stdout_t.

Definition sender :=
  ((lin ch =>
      match (readline) stdin with
      | (sig_intro msg stdin) =>
        let ch := (send ch) msg in
        let ch := (send ch) msg in
        match close ch with
        | tt => match (close_in) stdin with
                | tt => tt
                end
        end
      end) :
    (channel !(_ : string), !(_ : string), $) -o unit).

Definition Main :=
  match fork (ch : channel !(_ : string), !(_ : string), $) := _main_ in
        (sender) ch
  with
  | (tnsr_intro ch _main_) =>
    match recv ch with
    | (sig_intro msg1 ch) =>
      match recv ch with
      | (sig_intro msg2 ch) =>
        let stdout := ((printline) stdout) ((cat) msg1) "\n" in
        let stdout := ((printline) stdout) ((cat) msg2) "\n" in
        match close ch with
        | tt => match (close_out) stdout with
                | tt => _main_
                end
        end
      end
    end
  end.

--------------------------------------------------------------------------------
tcheck ok
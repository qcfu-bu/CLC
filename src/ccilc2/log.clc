desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#212)
| Some (A : U) : (A) -> (option A#213).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#216)
| cons (A : U) : (A) -> ((list A)) -> (list A#217).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#222 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#223 (S n#224)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#230 P#231).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#238 P#239).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#245 B#246).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#250).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Import stdout : stdout_t.

Inductive ref_msg : U :=
| GET : ref_msg
| SET : ref_msg
| FREE : ref_msg.

Definition ref_t :=
  ((fix ref_t n A =>
      match n with
      | O => $
      | (S n) =>
        ?(msg : ref_msg),
          match msg with
          | GET => !(_ : A), ((ref_t) n) A
          | SET => ?(_ : A), ((ref_t) n) A
          | FREE => $
          end
      end) :
    (nat) -> (U) -> proto).

Definition ref_handler :=
  ((fix ref_handler A n m =>
      lin ch =>
        (match n as x return (channel ((ref_t) x) A) -> unit with
         | O => fun ch => close ch
         | (S n) =>
           fun ch =>
             match recv ch with
             | (sig_intro msg ch) =>
               (match msg as x return
                  (channel match x with
                           | GET => !(_ : A), ((ref_t) n) A
                           | SET => ?(_ : A), ((ref_t) n) A
                           | FREE => $
                           end) ->
                    unit
                with
                | GET =>
                  fun ch =>
                    let ch := (send ch) m in ((((ref_handler) A) n) m) ch
                | SET =>
                  fun ch =>
                    match recv ch with
                    | (sig_intro m ch) => ((((ref_handler) A) n) m) ch
                    end
                | FREE => fun ch => close ch
                end) ch
             end
         end) ch) :
    forall (A : U), forall (n : nat), (A) -> (channel ((ref_t) n) A) -o unit).

Definition mk_ref :=
  ((fun A n m x =>
      fork (ref : channel ((ref_t) n) A) := x in
      ((((ref_handler) A) n) m) ref) :
    forall (A : U),
      forall (n : nat), (A) -> (main) -> (tnsr channel- ((ref_t) n) A main)).

Definition set_ref :=
  ((fun A n m => lin ref => let ref := (send ref) SET in (send ref) m) :
    forall (A : U),
      forall (n : nat),
        (A) -> (channel- ((ref_t) (S n)) A) -o channel- ((ref_t) n) A).

Definition get_ref :=
  ((fun A n => lin ref => let ref := (send ref) GET in recv ref) :
    forall (A : U),
      forall (n : nat),
        (channel- ((ref_t) (S n)) A) -o
          (sig A fun _ => channel- ((ref_t) n) A)).

Definition free_ref :=
  ((fun A n =>
      lin ref =>
        let ref := (send ref) FREE in match close ref with
                                      | tt => tt
                                      end) :
    forall (A : U), forall (n : nat), (channel- ((ref_t) (S n)) A) -o unit).

Definition Main :=
  match ((((mk_ref) ?9) 10000) "hello\n") _main_ with
  | (tnsr_intro ref _main_) =>
    match (((get_ref) ?10) ?11) ref with
    | (sig_intro msg1 ref) =>
      let ref := ((((set_ref) ?12) ?13) "world\n") ref in
      match (((get_ref) ?14) ?15) ref with
      | (sig_intro msg2 ref) =>
        let stdout := ((printline) stdout) msg1 in
        let stdout := ((printline) stdout) msg2 in
        match (((free_ref) ?16) ?17) ref with
        | tt => match (close_out) stdout with
                | tt => _main_
                end
        end
      end
    end
  end.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#5296)
| Some (A : U) : (A) -> (option A#5297).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#5300)
| cons (A : U) : (A) -> ((list A)) -> (list A#5301).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#5306 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#5307 (S n#5308)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#5314 P#5315).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#5322 P#5323).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#5329 B#5330).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#5334).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Import stdout : stdout_t.

Inductive ref_msg : U :=
| GET : ref_msg
| SET : ref_msg
| FREE : ref_msg.

Definition ref_t :=
  ((fix ref_t n A =>
      match n with
      | O => $
      | (S n) =>
        ?(msg : ref_msg),
          match msg with
          | GET => !(_ : A), ((ref_t) n) A
          | SET => ?(_ : A), ((ref_t) n) A
          | FREE => $
          end
      end) :
    (nat) -> (U) -> proto).

Definition ref_handler :=
  ((fix ref_handler A n m =>
      lin ch =>
        (match n as x return (channel ((ref_t) x) A) -> unit with
         | O => fun ch => close ch
         | (S n) =>
           fun ch =>
             match recv ch with
             | (sig_intro msg ch) =>
               (match msg as x return
                  (channel match x with
                           | GET => !(_ : A), ((ref_t) n) A
                           | SET => ?(_ : A), ((ref_t) n) A
                           | FREE => $
                           end) ->
                    unit
                with
                | GET =>
                  fun ch =>
                    let ch := (send ch) m in ((((ref_handler) A) n) m) ch
                | SET =>
                  fun ch =>
                    match recv ch with
                    | (sig_intro m ch) => ((((ref_handler) A) n) m) ch
                    end
                | FREE => fun ch => close ch
                end) ch
             end
         end) ch) :
    forall (A : U), forall (n : nat), (A) -> (channel ((ref_t) n) A) -o unit).

Definition mk_ref :=
  ((fun A n m x =>
      fork (ref : channel ((ref_t) n) A) := x in
      ((((ref_handler) A) n) m) ref) :
    forall (A : U),
      forall (n : nat), (A) -> (main) -> (tnsr channel- ((ref_t) n) A main)).

Definition set_ref :=
  ((fun A n m => lin ref => let ref := (send ref) SET in (send ref) m) :
    forall (A : U),
      forall (n : nat),
        (A) -> (channel- ((ref_t) (S n)) A) -o channel- ((ref_t) n) A).

Definition get_ref :=
  ((fun A n => lin ref => let ref := (send ref) GET in recv ref) :
    forall (A : U),
      forall (n : nat),
        (channel- ((ref_t) (S n)) A) -o
          (sig A fun _ => channel- ((ref_t) n) A)).

Definition free_ref :=
  ((fun A n =>
      lin ref =>
        let ref := (send ref) FREE in match close ref with
                                      | tt => tt
                                      end) :
    forall (A : U), forall (n : nat), (channel- ((ref_t) (S n)) A) -o unit).

Definition Main :=
  match ((((mk_ref) string) 10000) "hello\n") _main_ with
  | (tnsr_intro ref _main_) =>
    match (((get_ref) string) 9999) ref with
    | (sig_intro msg1 ref) =>
      let ref := ((((set_ref) string) 9998) "world\n") ref in
      match (((get_ref) string) 9997) ref with
      | (sig_intro msg2 ref) =>
        let stdout := ((printline) stdout) msg1 in
        let stdout := ((printline) stdout) msg2 in
        match (((free_ref) string) 9996) ref with
        | tt => match (close_out) stdout with
                | tt => _main_
                end
        end
      end
    end
  end.

--------------------------------------------------------------------------------
tcheck ok
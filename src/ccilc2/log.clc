desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#209)
| Some (A : U) : (A) -> (option A#210).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#213)
| cons (A : U) : (A) -> ((list A)) -> (list A#214).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#219 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#220 (S n#221)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#227 P#228).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#235 P#236).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#242 B#243).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#247).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Import out : stdout_t.

Definition exn_p :=
  ((fun A => !(b : bool), match b with
                          | true => !(_ : A), $
                          | false => $
                          end) :
    (U) -> proto).

Inductive Exn (A : U) : L :=
| Error (A : U) : (Exn A#324)
| Ok (A : U) : (A) -> (channel (exn_p) A) -> (Exn A#325).

Definition exn := ((fun A => (channel (exn_p) A) -> (Exn A)) : (U) -> U).

Definition ret :=
  ((fun A m ch => (Ok m ch)) : forall (A : U), (A) -> (exn) A).

Definition throw :=
  ((fun A ch =>
      let ch := (send ch) false in match close ch with
                                   | tt => Error
                                   end) :
    forall (A : U), (exn) A).

Definition bind :=
  ((fun A e f ch =>
      match (e) ch with
      | Error => Error
      | (Ok m ch) => ((f) m) ch
      end) :
    forall (A : U), ((exn) A) -> ((A) -> (exn) A) -> (exn) A).

Definition div2_exn_p :=
  ((fix div2_exn_p n =>
      match n with
      | O => ((ret) ?1) O
      | (S n) =>
        match n with
        | O => (throw) ?2
        | (S n) => (((bind) ?0) (div2_exn_p) n) fun n => ((ret) ?3) (S n)
        end
      end) :
    (nat) -> (exn) nat).

Definition try :=
  ((fun A =>
      lin m f_exn_p default =>
        match fork (ch : channel (exn_p) A) := m in
              match (f_exn_p) ch with
              | Error => tt
              | (Ok x ch) =>
                let ch := (send ch) true in let ch := (send ch) x in close ch
              end
        with
        | (tnsr_intro ch m) =>
          match recv ch with
          | (sig_intro b ch) =>
            (match b as x return
               (channel- match x with
                         | true => !(_ : A), $
                         | false => $
                         end) -o
                 (sig A fun _ => main)
             with
             | true =>
               lin ch =>
                 match recv ch with
                 | (sig_intro res ch) =>
                   match close ch with
                   | tt => (sig_intro res m)
                   end
                 end
             | false =>
               lin ch =>
                 match close ch with
                 | tt => (sig_intro default m)
                 end
             end) ch
          end
        end) :
    forall (A : U), (main) -o ((exn) A) -o (A) -o (sig A fun _ => main)).

Definition string_of_nat :=
  ((fix string_of_nat n =>
      match n with
      | O => "O"
      | (S n) => let n := (string_of_nat) n in ((cat) "S (") ((cat) n) ")"
      end) :
    (nat) -> string).

Definition Main :=
  match ((((try) ?4) _main_) (div2_exn_p) 14) O with
  | (sig_intro n _main_) =>
    let s := (string_of_nat) n in
    let out := ((printline) out) ((cat) s) "\n" in
    match (close_out) out with
    | tt => _main_
    end
  end.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#2611)
| Some (A : U) : (A) -> (option A#2612).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#2615)
| cons (A : U) : (A) -> ((list A)) -> (list A#2616).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#2621 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#2622 (S n#2623)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#2629 P#2630).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#2637 P#2638).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#2644 B#2645).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#2649).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Import out : stdout_t.

Definition exn_p :=
  ((fun A => !(b : bool), match b with
                          | true => !(_ : A), $
                          | false => $
                          end) :
    (U) -> proto).

Inductive Exn (A : U) : L :=
| Error (A : U) : (Exn A#2726)
| Ok (A : U) : (A) -> (channel (exn_p) A) -> (Exn A#2727).

Definition exn := ((fun A => (channel (exn_p) A) -> (Exn A)) : (U) -> U).

Definition ret :=
  ((fun A m ch => (Ok m ch)) : forall (A : U), (A) -> (exn) A).

Definition throw :=
  ((fun A ch =>
      let ch := (send ch) false in match close ch with
                                   | tt => Error
                                   end) :
    forall (A : U), (exn) A).

Definition bind :=
  ((fun A e f ch =>
      match (e) ch with
      | Error => Error
      | (Ok m ch) => ((f) m) ch
      end) :
    forall (A : U), ((exn) A) -> ((A) -> (exn) A) -> (exn) A).

Definition div2_exn_p :=
  ((fix div2_exn_p n =>
      match n with
      | O => ((ret) nat) O
      | (S n) =>
        match n with
        | O => (throw) nat
        | (S n) => (((bind) nat) (div2_exn_p) n) fun n => ((ret) nat) (S n)
        end
      end) :
    (nat) -> (exn) nat).

Definition try :=
  ((fun A =>
      lin m f_exn_p default =>
        match fork (ch : channel (exn_p) A) := m in
              match (f_exn_p) ch with
              | Error => tt
              | (Ok x ch) =>
                let ch := (send ch) true in let ch := (send ch) x in close ch
              end
        with
        | (tnsr_intro ch m) =>
          match recv ch with
          | (sig_intro b ch) =>
            (match b as x return
               (channel- match x with
                         | true => !(_ : A), $
                         | false => $
                         end) -o
                 (sig A fun _ => main)
             with
             | true =>
               lin ch =>
                 match recv ch with
                 | (sig_intro res ch) =>
                   match close ch with
                   | tt => (sig_intro res m)
                   end
                 end
             | false =>
               lin ch =>
                 match close ch with
                 | tt => (sig_intro default m)
                 end
             end) ch
          end
        end) :
    forall (A : U), (main) -o ((exn) A) -o (A) -o (sig A fun _ => main)).

Definition string_of_nat :=
  ((fix string_of_nat n =>
      match n with
      | O => "O"
      | (S n) => let n := (string_of_nat) n in ((cat) "S (") ((cat) n) ")"
      end) :
    (nat) -> string).

Definition Main :=
  match ((((try) nat) _main_) (div2_exn_p) 14) O with
  | (sig_intro n _main_) =>
    let s := (string_of_nat) n in
    let out := ((printline) out) ((cat) s) "\n" in
    match (close_out) out with
    | tt => _main_
    end
  end.

--------------------------------------------------------------------------------
tcheck ok
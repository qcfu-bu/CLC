desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#164)
| Some (A : U) : (A) -> (option A#165).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#168)
| cons (A : U) : (A) -> ((list A)) -> (list A#169).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#174 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#175 (S n#176)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#182 P#183).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#190 P#191).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#197 B#198).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#202).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Inductive Proto : U :=
| SEND : forall (A : U), ((A) -> Proto) -> Proto
| RECV : forall (A : U), ((A) -> Proto) -> Proto
| END : Proto.

Axiom Channel : (Proto) -> L.

Axiom Open : forall (p : Proto), (Channel) p.

Axiom Close : ((Channel) END) -> unit.

Axiom Send :
  forall (A : U),
    forall (p : (A) -> Proto),
      ((Channel) (SEND A p)) -> linear (m : A), (Channel) (p) m.

Axiom Recv :
  forall (A : U),
    forall (p : (A) -> Proto),
      ((Channel) (RECV A p)) -> (sig A fun m => (Channel) (p) m).

Definition Main :=
  let p :=
    (RECV
      bool
        fun b =>
          match b with
          | true => (SEND nat fun _ => END)
          | false => END
          end)
  in
  let ch := (Open) p in
  match (((Recv) ?4) ?5) ch with
  | (sig_intro msg ch) =>
    (match msg as b return
       ((Channel)
          match b with
          | true => (SEND nat fun _ => END)
          | false => END
          end) -o
         main
     with
     | true =>
       lin ch =>
         let ch := ((((Send) ?6) ?7) ch) 2 in
         match (Close) ch with
         | tt => _main_
         end
     | false => lin ch => match (Close) ch with
                          | tt => _main_
                          end
     end) ch
  end.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#1891)
| Some (A : U) : (A) -> (option A#1892).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#1895)
| cons (A : U) : (A) -> ((list A)) -> (list A#1896).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#1901 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#1902 (S n#1903)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#1909 P#1910).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#1917 P#1918).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#1924 B#1925).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#1929).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Definition stdin_rec :=
  ((fix stdin_rec _ =>
      !(b : bool),
        match b with
        | true => ?(_ : string), (stdin_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdin_t := (((stdin_rec) tt) : proto).

Definition readline :=
  ((fun ch => let ch := (send ch) true in recv ch) :
    (channel stdin_t) -> (sig string fun _ => channel stdin_t)).

Definition close_in :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdin_t) -> unit).

Definition stdout_rec :=
  ((fix stdout_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stdout_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stdout_t := (((stdout_rec) tt) : proto).

Definition printline :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stdout_t) -> (string) -o channel stdout_t).

Definition close_out :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stdout_t) -> unit).

Definition stderr_rec :=
  ((fix stderr_rec _ =>
      !(b : bool),
        match b with
        | true => !(_ : string), (stderr_rec) tt
        | false => $
        end) :
    (unit) -> proto).

Definition stderr_t := (((stderr_rec) tt) : proto).

Definition printerr :=
  ((fun ch => lin s => let ch := (send ch) true in (send ch) s) :
    (channel stderr_t) -> (string) -o channel stderr_t).

Definition close_err :=
  ((fun ch => let ch := (send ch) false in close ch) :
    (channel stderr_t) -> unit).

Inductive Proto : U :=
| SEND : forall (A : U), ((A) -> Proto) -> Proto
| RECV : forall (A : U), ((A) -> Proto) -> Proto
| END : Proto.

Axiom Channel : (Proto) -> L.

Axiom Open : forall (p : Proto), (Channel) p.

Axiom Close : ((Channel) END) -> unit.

Axiom Send :
  forall (A : U),
    forall (p : (A) -> Proto),
      ((Channel) (SEND A p)) -> linear (m : A), (Channel) (p) m.

Axiom Recv :
  forall (A : U),
    forall (p : (A) -> Proto),
      ((Channel) (RECV A p)) -> (sig A fun m => (Channel) (p) m).

Definition Main :=
  let p :=
    (RECV
      bool
        fun b =>
          match b with
          | true => (SEND nat fun _ => END)
          | false => END
          end)
  in
  let ch := (Open) p in
  match (((Recv) bool)
           fun b =>
             match b with
             | true => (SEND nat fun _ => END)
             | false => END
             end)
          ch
  with
  | (sig_intro msg ch) =>
    (match msg as b return
       ((Channel)
          match b with
          | true => (SEND nat fun _ => END)
          | false => END
          end) -o
         main
     with
     | true =>
       lin ch =>
         let ch := ((((Send) nat) fun _ => END) ch) 2 in
         match (Close) ch with
         | tt => _main_
         end
     | false => lin ch => match (Close) ch with
                          | tt => _main_
                          end
     end) ch
  end.

--------------------------------------------------------------------------------
tcheck ok
Import out : stdout_t.

Definition exn (A : U) : proto :=
  !(b : bool), if b then !A, $ else $.

Inductive Exn (A : U) : L :=
| Error : Exn A
| Ok : A -> channel (exn A) -> Exn A.

Definition throw (A : U) (ch : channel (exn A)) : Exn A :=
  let ch := send ch false in
  let () := close ch in
  Error.

Fixpoint div2_exn (n : nat) (ch : channel (exn nat)) : Exn nat :=
  match n with
  | O => Ok 0 ch
  | S n =>
    match n with
    | O => throw _ ch
    | S n => 
      let x := sx in
      match div2_exn n ch with
      | Error => Error
      | Ok n ch => Ok (S n) ch
      end
    end
  end.

Definition try (A : U) : 
  main -o (channel (exn A) -> Exn A) -o A -o sig A (fun _ => main) :=
  lin m f_exn default =>
  let ⟨ch, m⟩ := 
    fork (ch : channel (exn A)) := m in 
    match f_exn ch with
    | Error => tt
    | Ok x ch =>
      let ch := send ch true in
      let ch := send ch x in
      close ch
    end
  in
  let [b, ch] := recv ch in
  match b as x return
    channel- (if x then !A, $ else $) -o sig A (fun _ => main)
  with
  | true => lin ch =>
    let [res, ch] := recv ch in
    let () := close ch in
    [res, m]
  | false => lin ch =>
    let () := close ch in
    [default, m]
  end ch.

Fixpoint string_of_nat (n : nat) : string :=
  match n with
  | O => "O"
  | S n => 
    let n := string_of_nat n in
    cat "S (" (cat n ")")
  end.

Definition Main := 
  let [n, _main_] := try _ _main_ (div2_exn 15) 0 in
  let s := string_of_nat n in
  let out := printline out (cat s "\n") in
  let () := close_out out in
  _main_.

desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive base : U :=
| ll : base.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#269)
| Some (A : U) : (A) -> (option A#270).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#273)
| cons (A : U) : (A) -> ((list A)) -> (list A#274).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#279 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#280 (S n#281)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#287 P#288).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#295 P#296).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#302 B#303).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#307).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Inductive le (n : nat) : (nat) -> U :=
| le_n (n : nat) : (le n#329 n#329)
| le_S (n : nat) : forall (m : nat), ((le n m)) -> (le n#330 (S m#331)).

Definition lt := ((fun m n => (le (S m) n)) : (nat) -> (nat) -> U).

Inductive eq (A : U) (x : A) : (A) -> U :=
| refl (A : U) (x : A) : (eq A#341 x#342 x#342).

Definition eq_trans :=
  ((fun A x y z e1 e2 =>
      match e2 in (eq _ _ y) return (eq A x y) with
      | refl => e1
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (z : A), ((eq A x y)) -> ((eq A y z)) -> (eq A x z)).

Definition eq_sym :=
  ((fun A x y e =>
      match e in (eq _ _ y) return (eq A y x) with
      | refl => refl
      end) :
    forall (A : U),
      forall (x : A), forall (y : A), ((eq A x y)) -> (eq A y x)).

Definition u_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> U), ((eq A x y)) -> ((P) x) -> (P) y).

Definition l_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> L), ((eq A x y)) -> ((P) x) -> (P) y).

Axiom unsafeC : forall (A : L), (A) -> unit.

Axiom unsafeP : forall (A : L), A.

Definition Loc := ((nat) : U).

Axiom PtsTo : (Loc) -> (U) -> L.

Definition Ptr := ((fun A => (sig Loc fun l => ((PtsTo) l) A)) : (U) -> L).

Axiom New : forall (A : U), (A) -> (Ptr) A.

Axiom Free : forall (A : U), ((Ptr) A) -> unit.

Axiom Get :
  forall (A : U),
    forall (l : Loc), (((PtsTo) l) A) -> (sig A fun _ => ((PtsTo) l) A).

Axiom Set :
  forall (A : U),
    forall (B : U), (B) -> forall (l : Loc), (((PtsTo) l) A) -> ((PtsTo) l) B.

Inductive ArrVec (A : U) (l : Loc) : (nat) -> L :=
| Nil (A : U) (l : Loc) : (ArrVec A#438 l#439 O)
| Cons (A : U)
         (l : Loc)
           : forall (n : nat),
               (((PtsTo) ((addn) l) n) A) ->
                 ((ArrVec A l n)) -> (ArrVec A#440 l#441 (S n#442)).

Definition Array :=
  ((fun A n => (sig Loc fun l => (ArrVec A l n))) : (U) -> (nat) -> L).

Definition nth :=
  ((fix nth A l m n pf v =>
      (match pf in (le _ n) return
         ((ArrVec A l n)) ->
           (tnsr
             ((PtsTo) ((addn) l) m) A
               (((PtsTo) ((addn) l) m) A) -o (ArrVec A l n))
       with
       | le_n =>
         fun v =>
           (match v in (ArrVec _ _ n) return
              match n with
              | O => base
              | (S n0) =>
                ((eq ?8 m n0)) -o
                  (tnsr
                    ((PtsTo) ((addn) l) n0) A
                      (((PtsTo) ((addn) l) n0) A) -o (ArrVec A l n))
              end
            with
            | Nil => ll
            | (Cons n c v) => lin _ => (tnsr_intro c lin c => (Cons n c v))
            end) refl
       | (le_S _ pf) =>
         fun v =>
           (match v in (ArrVec _ _ n) return
              match n with
              | O => base
              | (S n0) =>
                (((lt) m) n0) -o
                  (tnsr
                    ((PtsTo) ((addn) l) m) A
                      (((PtsTo) ((addn) l) m) A) -o (ArrVec A l n))
              end
            with
            | Nil => ll
            | (Cons n c0 v0) =>
              lin pf =>
                match ((((((nth) A) l) m) n) pf) v0 with
                | (tnsr_intro c f) =>
                  (tnsr_intro c lin c => (Cons n c0 (f) c))
                end
            end) pf
       end) v) :
    forall (A : U),
      forall (l : nat),
        forall (m : nat),
          forall (n : nat),
            (((lt) m) n) ->
              ((ArrVec A l n)) ->
                (tnsr
                  ((PtsTo) ((addn) l) m) A
                    (((PtsTo) ((addn) l) m) A) -o (ArrVec A l n))).

Definition index :=
  ((fun A m n pf a =>
      match a with
      | (sig_intro l v) =>
        match ((((((nth) ?9) ?10) ?11) ?12) pf) v with
        | (tnsr_intro c f) =>
          match (((Get) ?13) ((addn) l) m) c with
          | (sig_intro x c) => (sig_intro x (sig_intro l (f) c))
          end
        end
      end) :
    forall (A : U),
      forall (m : nat),
        forall (n : nat),
          (((lt) m) n) -> (((Array) A) n) -> (sig A fun _ => ((Array) A) n)).

Definition Just0 := (((ex nat fun x => (eq ?14 x O))) : U).

Definition Main := tt.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive base : U :=
| ll : base.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#3819)
| Some (A : U) : (A) -> (option A#3820).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#3823)
| cons (A : U) : (A) -> ((list A)) -> (list A#3824).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#3829 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#3830 (S n#3831)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#3837 P#3838).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#3845 P#3846).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#3852 B#3853).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#3857).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Inductive le (n : nat) : (nat) -> U :=
| le_n (n : nat) : (le n#3879 n#3879)
| le_S (n : nat) : forall (m : nat), ((le n m)) -> (le n#3880 (S m#3881)).

Definition lt := ((fun m n => (le (S m) n)) : (nat) -> (nat) -> U).

Inductive eq (A : U) (x : A) : (A) -> U :=
| refl (A : U) (x : A) : (eq A#3891 x#3892 x#3892).

Definition eq_trans :=
  ((fun A x y z e1 e2 =>
      match e2 in (eq _ _ y) return (eq A x y) with
      | refl => e1
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (z : A), ((eq A x y)) -> ((eq A y z)) -> (eq A x z)).

Definition eq_sym :=
  ((fun A x y e =>
      match e in (eq _ _ y) return (eq A y x) with
      | refl => refl
      end) :
    forall (A : U),
      forall (x : A), forall (y : A), ((eq A x y)) -> (eq A y x)).

Definition u_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> U), ((eq A x y)) -> ((P) x) -> (P) y).

Definition l_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> L), ((eq A x y)) -> ((P) x) -> (P) y).

Axiom unsafeC : forall (A : L), (A) -> unit.

Axiom unsafeP : forall (A : L), A.

Definition Loc := ((nat) : U).

Axiom PtsTo : (Loc) -> (U) -> L.

Definition Ptr := ((fun A => (sig Loc fun l => ((PtsTo) l) A)) : (U) -> L).

Axiom New : forall (A : U), (A) -> (Ptr) A.

Axiom Free : forall (A : U), ((Ptr) A) -> unit.

Axiom Get :
  forall (A : U),
    forall (l : Loc), (((PtsTo) l) A) -> (sig A fun _ => ((PtsTo) l) A).

Axiom Set :
  forall (A : U),
    forall (B : U), (B) -> forall (l : Loc), (((PtsTo) l) A) -> ((PtsTo) l) B.

Inductive ArrVec (A : U) (l : Loc) : (nat) -> L :=
| Nil (A : U) (l : Loc) : (ArrVec A#3988 l#3989 O)
| Cons (A : U)
         (l : Loc)
           : forall (n : nat),
               (((PtsTo) ((addn) l) n) A) ->
                 ((ArrVec A l n)) -> (ArrVec A#3990 l#3991 (S n#3992)).

Definition Array :=
  ((fun A n => (sig Loc fun l => (ArrVec A l n))) : (U) -> (nat) -> L).

Definition nth :=
  ((fix nth A l m n pf v =>
      (match pf in (le _ n) return
         ((ArrVec A l n)) ->
           (tnsr
             ((PtsTo) ((addn) l) m) A
               (((PtsTo) ((addn) l) m) A) -o (ArrVec A l n))
       with
       | le_n =>
         fun v =>
           (match v in (ArrVec _ _ n) return
              match n with
              | O => base
              | (S n0) =>
                ((eq nat m n0)) -o
                  (tnsr
                    ((PtsTo) ((addn) l) n0) A
                      (((PtsTo) ((addn) l) n0) A) -o (ArrVec A l n))
              end
            with
            | Nil => ll
            | (Cons n c v) => lin _ => (tnsr_intro c lin c => (Cons n c v))
            end) refl
       | (le_S _ pf) =>
         fun v =>
           (match v in (ArrVec _ _ n) return
              match n with
              | O => base
              | (S n0) =>
                (((lt) m) n0) -o
                  (tnsr
                    ((PtsTo) ((addn) l) m) A
                      (((PtsTo) ((addn) l) m) A) -o (ArrVec A l n))
              end
            with
            | Nil => ll
            | (Cons n c0 v0) =>
              lin pf =>
                match ((((((nth) A) l) m) n) pf) v0 with
                | (tnsr_intro c f) =>
                  (tnsr_intro c lin c => (Cons n c0 (f) c))
                end
            end) pf
       end) v) :
    forall (A : U),
      forall (l : nat),
        forall (m : nat),
          forall (n : nat),
            (((lt) m) n) ->
              ((ArrVec A l n)) ->
                (tnsr
                  ((PtsTo) ((addn) l) m) A
                    (((PtsTo) ((addn) l) m) A) -o (ArrVec A l n))).

Definition index :=
  ((fun A m n pf a =>
      match a with
      | (sig_intro l v) =>
        match ((((((nth) A) l) m) n) pf) v with
        | (tnsr_intro c f) =>
          match (((Get) A) ((addn) l) m) c with
          | (sig_intro x c) => (sig_intro x (sig_intro l (f) c))
          end
        end
      end) :
    forall (A : U),
      forall (m : nat),
        forall (n : nat),
          (((lt) m) n) -> (((Array) A) n) -> (sig A fun _ => ((Array) A) n)).

Definition Just0 := (((ex nat fun x => (eq nat x O))) : U).

Definition Main := tt.


desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive base : U :=
| ll : base.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#232)
| Some (A : U) : (A) -> (option A#233).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#236)
| cons (A : U) : (A) -> ((list A)) -> (list A#237).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#242 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#243 (S n#244)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#250 P#251).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#258 P#259).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#265 B#266).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#270).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Inductive le (n : nat) : (nat) -> U :=
| le_n (n : nat) : (le n#292 n#292)
| le_S (n : nat) : forall (m : nat), ((le n m)) -> (le n#293 (S m#294)).

Definition lt := ((fun m n => (le (S m) n)) : (nat) -> (nat) -> U).

Inductive eq (A : U) (x : A) : (A) -> U :=
| refl (A : U) (x : A) : (eq A#304 x#305 x#305).

Definition eq_trans :=
  ((fun A x y z e1 e2 =>
      match e2 in (eq _ _ y) return (eq A x y) with
      | refl => e1
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (z : A), ((eq A x y)) -> ((eq A y z)) -> (eq A x z)).

Definition eq_sym :=
  ((fun A x y e =>
      match e in (eq _ _ y) return (eq A y x) with
      | refl => refl
      end) :
    forall (A : U),
      forall (x : A), forall (y : A), ((eq A x y)) -> (eq A y x)).

Definition u_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> U), ((eq A x y)) -> ((P) x) -> (P) y).

Definition l_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> L), ((eq A x y)) -> ((P) x) -> (P) y).

Axiom unsafeC : forall (A : L), (A) -> unit.

Axiom unsafeP : forall (A : L), A.

Definition Loc := ((nat) : U).

Axiom PtsTo : (Loc) -> (U) -> L.

Definition Ptr := ((fun A => (sig Loc fun l => ((PtsTo) l) A)) : (U) -> L).

Axiom New : forall (A : U), (A) -> (Ptr) A.

Axiom Free : forall (A : U), ((Ptr) A) -> unit.

Axiom Get :
  forall (A : U),
    forall (l : Loc), (((PtsTo) l) A) -> (sig A fun _ => ((PtsTo) l) A).

Axiom Set :
  forall (A : U),
    forall (B : U), (B) -> forall (l : Loc), (((PtsTo) l) A) -> ((PtsTo) l) B.

Inductive list (A : L) : (nat) -> L :=
| nil (A : L) : (list A#400 O)
| cons (A : L)
         : forall (n : nat), (A) -> ((list A n)) -> (list A#401 (S n#402)).

Definition kappend :=
  ((fix kappend A B m n =>
      lin ls1 ls2 k =>
        (match ls1 in (list _ x) return (((list A ((addn) x) n)) -o B) -o B
         with
         | nil => lin k => (k) ls2
         | (cons m hd tl) =>
           lin k =>
             (((((((kappend) A) B) m) n) tl) ls2)
               lin res => (k) (cons ((addn) m) n hd res)
         end) k) :
    forall (A : L),
      forall (B : L),
        forall (m : nat),
          forall (n : nat),
            ((list A m)) -o
              ((list A n)) -o (((list A ((addn) m) n)) -o B) -o B).

Definition append :=
  ((fun A m n =>
      lin ls1 ls2 =>
        (((((((kappend) A) (list A ((addn) m) n)) m) n) ls1) ls2)
          lin res => res) :
    forall (A : L),
      forall (m : nat),
        forall (n : nat),
          ((list A m)) -o ((list A n)) -o (list A ((addn) m) n)).

Definition Main := tt.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive base : U :=
| ll : base.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn :=
  ((fix addn m n => match m with
                    | O => n
                    | (S m) => (S ((addn) m) n)
                    end) :
    (nat) -> (nat) -> nat).

Inductive option (A : U) : U :=
| None (A : U) : (option A#2827)
| Some (A : U) : (A) -> (option A#2828).

Inductive list (A : U) : U :=
| nil (A : U) : (list A#2831)
| cons (A : U) : (A) -> ((list A)) -> (list A#2832).

Inductive vec (A : U) : (nat) -> U :=
| vnil (A : U) : (vec A#2837 O)
| vcons (A : U)
          : forall (n : nat), (A) -> ((vec A n)) -> (vec A#2838 (S n#2839)).

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#2845 P#2846).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#2853 P#2854).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#2860 B#2861).

Inductive box (A : U) : L :=
| box_intro (A : U) : (A) -> (box A#2865).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Inductive le (n : nat) : (nat) -> U :=
| le_n (n : nat) : (le n#2887 n#2887)
| le_S (n : nat) : forall (m : nat), ((le n m)) -> (le n#2888 (S m#2889)).

Definition lt := ((fun m n => (le (S m) n)) : (nat) -> (nat) -> U).

Inductive eq (A : U) (x : A) : (A) -> U :=
| refl (A : U) (x : A) : (eq A#2899 x#2900 x#2900).

Definition eq_trans :=
  ((fun A x y z e1 e2 =>
      match e2 in (eq _ _ y) return (eq A x y) with
      | refl => e1
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (z : A), ((eq A x y)) -> ((eq A y z)) -> (eq A x z)).

Definition eq_sym :=
  ((fun A x y e =>
      match e in (eq _ _ y) return (eq A y x) with
      | refl => refl
      end) :
    forall (A : U),
      forall (x : A), forall (y : A), ((eq A x y)) -> (eq A y x)).

Definition u_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> U), ((eq A x y)) -> ((P) x) -> (P) y).

Definition l_ind :=
  ((fun A x y P e f =>
      match e in (eq _ _ y) return (P) y with
      | refl => f
      end) :
    forall (A : U),
      forall (x : A),
        forall (y : A),
          forall (P : (A) -> L), ((eq A x y)) -> ((P) x) -> (P) y).

Axiom unsafeC : forall (A : L), (A) -> unit.

Axiom unsafeP : forall (A : L), A.

Definition Loc := ((nat) : U).

Axiom PtsTo : (Loc) -> (U) -> L.

Definition Ptr := ((fun A => (sig Loc fun l => ((PtsTo) l) A)) : (U) -> L).

Axiom New : forall (A : U), (A) -> (Ptr) A.

Axiom Free : forall (A : U), ((Ptr) A) -> unit.

Axiom Get :
  forall (A : U),
    forall (l : Loc), (((PtsTo) l) A) -> (sig A fun _ => ((PtsTo) l) A).

Axiom Set :
  forall (A : U),
    forall (B : U), (B) -> forall (l : Loc), (((PtsTo) l) A) -> ((PtsTo) l) B.

Inductive list (A : L) : (nat) -> L :=
| nil (A : L) : (list A#2995 O)
| cons (A : L)
         : forall (n : nat), (A) -> ((list A n)) -> (list A#2996 (S n#2997)).

Definition kappend :=
  ((fix kappend A B m n =>
      lin ls1 ls2 k =>
        (match ls1 in (list _ x) return (((list A ((addn) x) n)) -o B) -o B
         with
         | nil => lin k => (k) ls2
         | (cons m hd tl) =>
           lin k =>
             (((((((kappend) A) B) m) n) tl) ls2)
               lin res => (k) (cons ((addn) m) n hd res)
         end) k) :
    forall (A : L),
      forall (B : L),
        forall (m : nat),
          forall (n : nat),
            ((list A m)) -o
              ((list A n)) -o (((list A ((addn) m) n)) -o B) -o B).

Definition append :=
  ((fun A m n =>
      lin ls1 ls2 =>
        (((((((kappend) A) (list A ((addn) m) n)) m) n) ls1) ls2)
          lin res => res) :
    forall (A : L),
      forall (m : nat),
        forall (n : nat),
          ((list A m)) -o ((list A n)) -o (list A ((addn) m) n)).

Definition Main := tt.

--------------------------------------------------------------------------------
tcheck ok
desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive base : U :=
| ll : base.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn#214 :=
  ((fix addn#215 m#216 n#217 =>
      match m#216 with
      | O => n#217
      | (S m#218) => (S ((addn#215) m#218) n#217)
      end) :
    (nat) -> (nat) -> nat).

Inductive option (A#221 : U) : U :=
| None (A#222 : U) : (option A#222)
| Some (A#223 : U) : (A#223) -> (option A#223).

Inductive list (A#225 : U) : U :=
| nil (A#226 : U) : (list A#226)
| cons (A#227 : U) : (A#227) -> ((list A#227)) -> (list A#227).

Inductive vec (A#230 : U) : (nat) -> U :=
| vnil (A#232 : U) : (vec A#232 O)
| vcons (A#233 : U)
          : forall (n#234 : nat),
              (A#233) -> ((vec A#233 n#234)) -> (vec A#233 (S n#234)).

Inductive ex (A#237 : U) (P#238 : (A#237) -> U) : U :=
| ex_intro (A#240 : U)
             (P#241 : (A#240) -> U)
               : forall (x#243 : A#240), ((P#241) x#243) -> (ex A#240 P#241).

Inductive sig (A#245 : U) (P#246 : (A#245) -> L) : L :=
| sig_intro (A#248 : U)
              (P#249 : (A#248) -> L)
                : forall (x#251 : A#248),
                    ((P#249) x#251) -> (sig A#248 P#249).

Inductive tnsr (A#253 : L) (B#254 : L) : L :=
| tnsr_intro (A#255 : L)
               (B#256 : L) : (A#255) -> (B#256) -> (tnsr A#255 B#256).

Inductive box (A#259 : U) : L :=
| box_intro (A#260 : U) : (A#260) -> (box A#260).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat#272 :=
  ((fix cat#273 s1#274 s2#275 =>
      match s1#274 with
      | EmptyString => s2#275
      | (String c#276 s1#277) => (String c#276 ((cat#273) s1#277) s2#275)
      end) :
    (string) -> (string) -> string).

Inductive le (n#280 : nat) : (nat) -> U :=
| le_n (n#282 : nat) : (le n#282 n#282)
| le_S (n#283 : nat)
         : forall (m#284 : nat), ((le n#283 m#284)) -> (le n#283 (S m#284)).

Definition lt#286 :=
  ((fun m#287 n#288 => (le (S m#287) n#288)) : (nat) -> (nat) -> U).

Inductive eq (A#291 : U) (x#292 : A#291) : (A#291) -> U :=
| refl (A#294 : U) (x#295 : A#294) : (eq A#294 x#295 x#295).

Definition eq_trans#296 :=
  ((fun A#297 x#298 y#299 z#300 e1#301 e2#302 =>
      match e2#302 in (eq _#303 _#304 y#305) return (eq A#297 x#298 y#305)
      with
      | refl => e1#301
      end) :
    forall (A#306 : U),
      forall (x#307 : A#306),
        forall (y#308 : A#306),
          forall (z#309 : A#306),
            ((eq A#306 x#307 y#308)) ->
              ((eq A#306 y#308 z#309)) -> (eq A#306 x#307 z#309)).

Definition eq_sym#312 :=
  ((fun A#313 x#314 y#315 e#316 =>
      match e#316 in (eq _#317 _#318 y#319) return (eq A#313 y#319 x#314)
      with
      | refl => refl
      end) :
    forall (A#320 : U),
      forall (x#321 : A#320),
        forall (y#322 : A#320),
          ((eq A#320 x#321 y#322)) -> (eq A#320 y#322 x#321)).

Definition u_ind#324 :=
  ((fun A#325 x#326 y#327 P#328 e#329 f#330 =>
      match e#329 in (eq _#331 _#332 y#333) return (P#328) y#333 with
      | refl => f#330
      end) :
    forall (A#334 : U),
      forall (x#335 : A#334),
        forall (y#336 : A#334),
          forall (P#337 : (A#334) -> U),
            ((eq A#334 x#335 y#336)) -> ((P#337) x#335) -> (P#337) y#336).

Definition l_ind#341 :=
  ((fun A#342 x#343 y#344 P#345 e#346 f#347 =>
      match e#346 in (eq _#348 _#349 y#350) return (P#345) y#350 with
      | refl => f#347
      end) :
    forall (A#351 : U),
      forall (x#352 : A#351),
        forall (y#353 : A#351),
          forall (P#354 : (A#351) -> L),
            ((eq A#351 x#352 y#353)) -> ((P#354) x#352) -> (P#354) y#353).

Axiom unsafeC#358 : forall (A#359 : L), (A#359) -> unit.

Axiom unsafeP#361 : forall (A#362 : L), A#362.

Definition Loc#363 := ((nat) : U).

Axiom PtsTo#364 : (Loc#363) -> (U) -> L.

Definition Ptr#367 :=
  ((fun A#368 => (sig Loc#363 fun l#369 => ((PtsTo#364) l#369) A#368)) :
    (U) -> L).

Axiom New#371 : forall (A#372 : U), (A#372) -> (Ptr#367) A#372.

Axiom Free#374 : forall (A#375 : U), ((Ptr#367) A#375) -> unit.

Axiom Get#377 :
  forall (A#378 : U),
    forall (l#379 : Loc#363),
      (((PtsTo#364) l#379) A#378) ->
        (sig A#378 fun _#381 => ((PtsTo#364) l#379) A#378).

Axiom Set#382 :
  forall (A#383 : U),
    forall (B#384 : U),
      (B#384) ->
        forall (l#386 : Loc#363),
          (((PtsTo#364) l#386) A#383) -> ((PtsTo#364) l#386) B#384.

Inductive proto : U :=
| SEND : forall (A#388 : U), ((A#388) -> proto) -> proto
| RECV : forall (A#391 : U), ((A#391) -> proto) -> proto
| END : proto.

Axiom channel#394 : (proto) -> L.

Axiom open#396 : forall (p#397 : proto), (channel#394) p#397.

Axiom close#398 : ((channel#394) END) -> unit.

Axiom send#400 :
  forall (A#401 : U),
    forall (p#402 : (A#401) -> proto),
      ((channel#394) (SEND A#401 p#402)) ->
        linear (m#405 : A#401), (channel#394) (p#402) m#405.

Axiom recv#406 :
  forall (A#407 : U),
    forall (p#408 : (A#407) -> proto),
      ((channel#394) (RECV A#407 p#408)) ->
        (sig A#407 fun m#411 => (channel#394) (p#408) m#411).

Definition Main :=
  let p#412 :=
    (RECV
      bool
        fun b#413 =>
          match b#413 with
          | true => (SEND nat fun _#414 => END)
          | false => END
          end)
  in
  let ch#415 := (open#396) p#412 in
  match (((recv#406) ?4) ?5) ch#415 with
  | (sig_intro msg#416 ch#417) =>
    (match msg#416 as b#418 return
       ((channel#394)
          match b#418 with
          | true => (SEND nat fun _#420 => END)
          | false => END
          end) -o
         unit
     with
     | true =>
       lin ch#421 =>
         let ch#422 := ((((send#400) ?6) ?7) ch#421) 2 in (close#398) ch#422
     | false => lin ch#423 => (close#398) ch#423
     end) ch#417
  end.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive base : U :=
| ll : base.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Definition addn#2212 :=
  ((fix addn#2213 m#2214 n#2215 =>
      match m#2214 with
      | O => n#2215
      | (S m#2216) => (S ((addn#2213) m#2216) n#2215)
      end) :
    (nat) -> (nat) -> nat).

Inductive option (A#2219 : U) : U :=
| None (A#2220 : U) : (option A#2220)
| Some (A#2221 : U) : (A#2221) -> (option A#2221).

Inductive list (A#2223 : U) : U :=
| nil (A#2224 : U) : (list A#2224)
| cons (A#2225 : U) : (A#2225) -> ((list A#2225)) -> (list A#2225).

Inductive vec (A#2228 : U) : (nat) -> U :=
| vnil (A#2230 : U) : (vec A#2230 O)
| vcons (A#2231 : U)
          : forall (n#2232 : nat),
              (A#2231) -> ((vec A#2231 n#2232)) -> (vec A#2231 (S n#2232)).

Inductive ex (A#2235 : U) (P#2236 : (A#2235) -> U) : U :=
| ex_intro (A#2238 : U)
             (P#2239 : (A#2238) -> U)
               : forall (x#2241 : A#2238),
                   ((P#2239) x#2241) -> (ex A#2238 P#2239).

Inductive sig (A#2243 : U) (P#2244 : (A#2243) -> L) : L :=
| sig_intro (A#2246 : U)
              (P#2247 : (A#2246) -> L)
                : forall (x#2249 : A#2246),
                    ((P#2247) x#2249) -> (sig A#2246 P#2247).

Inductive tnsr (A#2251 : L) (B#2252 : L) : L :=
| tnsr_intro (A#2253 : L)
               (B#2254 : L) : (A#2253) -> (B#2254) -> (tnsr A#2253 B#2254).

Inductive box (A#2257 : U) : L :=
| box_intro (A#2258 : U) : (A#2258) -> (box A#2258).

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat#2270 :=
  ((fix cat#2271 s1#2272 s2#2273 =>
      match s1#2272 with
      | EmptyString => s2#2273
      | (String c#2274 s1#2275) =>
        (String c#2274 ((cat#2271) s1#2275) s2#2273)
      end) :
    (string) -> (string) -> string).

Inductive le (n#2278 : nat) : (nat) -> U :=
| le_n (n#2280 : nat) : (le n#2280 n#2280)
| le_S (n#2281 : nat)
         : forall (m#2282 : nat),
             ((le n#2281 m#2282)) -> (le n#2281 (S m#2282)).

Definition lt#2284 :=
  ((fun m#2285 n#2286 => (le (S m#2285) n#2286)) : (nat) -> (nat) -> U).

Inductive eq (A#2289 : U) (x#2290 : A#2289) : (A#2289) -> U :=
| refl (A#2292 : U) (x#2293 : A#2292) : (eq A#2292 x#2293 x#2293).

Definition eq_trans#2294 :=
  ((fun A#2295 x#2296 y#2297 z#2298 e1#2299 e2#2300 =>
      match e2#2300 in (eq _#2301 _#2302 y#2303) return
        (eq A#2295 x#2296 y#2303)
      with
      | refl => e1#2299
      end) :
    forall (A#2304 : U),
      forall (x#2305 : A#2304),
        forall (y#2306 : A#2304),
          forall (z#2307 : A#2304),
            ((eq A#2304 x#2305 y#2306)) ->
              ((eq A#2304 y#2306 z#2307)) -> (eq A#2304 x#2305 z#2307)).

Definition eq_sym#2310 :=
  ((fun A#2311 x#2312 y#2313 e#2314 =>
      match e#2314 in (eq _#2315 _#2316 y#2317) return
        (eq A#2311 y#2317 x#2312)
      with
      | refl => refl
      end) :
    forall (A#2318 : U),
      forall (x#2319 : A#2318),
        forall (y#2320 : A#2318),
          ((eq A#2318 x#2319 y#2320)) -> (eq A#2318 y#2320 x#2319)).

Definition u_ind#2322 :=
  ((fun A#2323 x#2324 y#2325 P#2326 e#2327 f#2328 =>
      match e#2327 in (eq _#2329 _#2330 y#2331) return (P#2326) y#2331 with
      | refl => f#2328
      end) :
    forall (A#2332 : U),
      forall (x#2333 : A#2332),
        forall (y#2334 : A#2332),
          forall (P#2335 : (A#2332) -> U),
            ((eq A#2332 x#2333 y#2334)) ->
              ((P#2335) x#2333) -> (P#2335) y#2334).

Definition l_ind#2339 :=
  ((fun A#2340 x#2341 y#2342 P#2343 e#2344 f#2345 =>
      match e#2344 in (eq _#2346 _#2347 y#2348) return (P#2343) y#2348 with
      | refl => f#2345
      end) :
    forall (A#2349 : U),
      forall (x#2350 : A#2349),
        forall (y#2351 : A#2349),
          forall (P#2352 : (A#2349) -> L),
            ((eq A#2349 x#2350 y#2351)) ->
              ((P#2352) x#2350) -> (P#2352) y#2351).

Axiom unsafeC#2356 : forall (A#2357 : L), (A#2357) -> unit.

Axiom unsafeP#2359 : forall (A#2360 : L), A#2360.

Definition Loc#2361 := ((nat) : U).

Axiom PtsTo#2362 : (Loc#2361) -> (U) -> L.

Definition Ptr#2365 :=
  ((fun A#2366 => (sig Loc#2361 fun l#2367 => ((PtsTo#2362) l#2367) A#2366)) :
    (U) -> L).

Axiom New#2369 : forall (A#2370 : U), (A#2370) -> (Ptr#2365) A#2370.

Axiom Free#2372 : forall (A#2373 : U), ((Ptr#2365) A#2373) -> unit.

Axiom Get#2375 :
  forall (A#2376 : U),
    forall (l#2377 : Loc#2361),
      (((PtsTo#2362) l#2377) A#2376) ->
        (sig A#2376 fun _#2379 => ((PtsTo#2362) l#2377) A#2376).

Axiom Set#2380 :
  forall (A#2381 : U),
    forall (B#2382 : U),
      (B#2382) ->
        forall (l#2384 : Loc#2361),
          (((PtsTo#2362) l#2384) A#2381) -> ((PtsTo#2362) l#2384) B#2382.

Inductive proto : U :=
| SEND : forall (A#2386 : U), ((A#2386) -> proto) -> proto
| RECV : forall (A#2389 : U), ((A#2389) -> proto) -> proto
| END : proto.

Axiom channel#2392 : (proto) -> L.

Axiom open#2394 : forall (p#2395 : proto), (channel#2392) p#2395.

Axiom close#2396 : ((channel#2392) END) -> unit.

Axiom send#2398 :
  forall (A#2399 : U),
    forall (p#2400 : (A#2399) -> proto),
      ((channel#2392) (SEND A#2399 p#2400)) ->
        linear (m#2403 : A#2399), (channel#2392) (p#2400) m#2403.

Axiom recv#2404 :
  forall (A#2405 : U),
    forall (p#2406 : (A#2405) -> proto),
      ((channel#2392) (RECV A#2405 p#2406)) ->
        (sig A#2405 fun m#2409 => (channel#2392) (p#2406) m#2409).

Definition Main :=
  let p#2410 :=
    (RECV
      bool
        fun b#2411 =>
          match b#2411 with
          | true => (SEND nat fun _#2412 => END)
          | false => END
          end)
  in
  let ch#2413 := (open#2394) p#2410 in
  match (((recv#2404) bool)
           fun b#2414 =>
             match b#2414 with
             | true => (SEND nat fun _#2415 => END)
             | false => END
             end)
          ch#2413
  with
  | (sig_intro msg#2416 ch#2417) =>
    (match msg#2416 as b#2418 return
       ((channel#2392)
          match b#2418 with
          | true => (SEND nat fun _#2420 => END)
          | false => END
          end) -o
         unit
     with
     | true =>
       lin ch#2421 =>
         let ch#2422 := ((((send#2398) nat) fun _#2423 => END) ch#2421) 2 in
         (close#2396) ch#2422
     | false => lin ch#2424 => (close#2396) ch#2424
     end) ch#2417
  end.

--------------------------------------------------------------------------------
tcheck ok
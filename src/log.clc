desugar ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#118 P#119).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#126 P#127).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#133 B#134).

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Import stdout 2 as _stdout_.

Inductive ref_msg : U :=
| GET : ref_msg
| SET : ref_msg
| FREE : ref_msg.

Definition ref_t :=
  ((fix ref_t A =>
      ?(msg : ref_msg),
        match msg with
        | GET => !(_ : A), (ref_t) A
        | SET => ?(_ : A), (ref_t) A
        | FREE => $
        end) :
    (U) -> proto).

Definition ref_handler :=
  ((fix ref_handler A m =>
      lin ch =>
        match recv ch with
        | (sig_intro msg ch) =>
          (match msg as x return
             (channel match x with
                      | GET => !(_ : A), (ref_t) A
                      | SET => ?(_ : A), (ref_t) A
                      | FREE => $
                      end) ->
               unit
           with
           | GET =>
             fun ch => let ch := (send ch) m in (((ref_handler) A) m) ch
           | SET =>
             fun ch =>
               match recv ch with
               | (sig_intro m ch) => (((ref_handler) A) m) ch
               end
           | FREE => fun ch => close ch
           end) ch
        end) :
    forall (A : U), (A) -> (channel (ref_t) A) -o unit).

Definition mk_ref :=
  ((fun A m x =>
      fork (ref : channel (ref_t) A) := x in (((ref_handler) A) m) ref) :
    forall (A : U), (A) -> (main) -> (tnsr channel ~(ref_t) A main)).

Definition set_ref :=
  ((fun A m => lin ref => let ref := (send ref) SET in (send ref) m) :
    forall (A : U), (A) -> (channel ~(ref_t) A) -o channel ~(ref_t) A).

Definition get_ref :=
  ((fun A => lin ref => let ref := (send ref) GET in recv ref) :
    forall (A : U),
      (channel ~(ref_t) A) -o (sig A fun _ => channel ~(ref_t) A)).

Definition free_ref :=
  ((fun A =>
      lin ref =>
        let ref := (send ref) FREE in match close ref with
                                      | tt => tt
                                      end) :
    forall (A : U), (channel ~(ref_t) A) -o unit).

Definition Main :=
  match (((mk_ref) ?0) "hello\n") _main_ with
  | (tnsr_intro ref _main_) =>
    match ((get_ref) ?1) ref with
    | (sig_intro msg1 ref) =>
      let ref := (((set_ref) ?2) "world\n") ref in
      match ((get_ref) ?3) ref with
      | (sig_intro msg2 ref) =>
        let _stdout_ := (send _stdout_) msg1 in
        let _stdout_ := (send _stdout_) msg2 in
        match ((free_ref) ?4) ref with
        | tt => match close _stdout_ with
                | tt => _main_
                end
        end
      end
    end
  end.

elab ok
--------------------------------------------------------------------------------
Inductive unit : U :=
| tt : unit.

Inductive bool : U :=
| true : bool
| false : bool.

Inductive ex (A : U) (P : (A) -> U) : U :=
| ex_intro (A : U)
             (P : (A) -> U) : forall (x : A), ((P) x) -> (ex A#2949 P#2950).

Inductive sig (A : U) (P : (A) -> L) : L :=
| sig_intro (A : U)
              (P : (A) -> L) : forall (x : A), ((P) x) -> (sig A#2957 P#2958).

Inductive tnsr (A : L) (B : L) : L :=
| tnsr_intro (A : L) (B : L) : (A) -> (B) -> (tnsr A#2964 B#2965).

Inductive nat : U :=
| O : nat
| S : (nat) -> nat.

Inductive ascii : U :=
| Ascii : (bool) ->
            (bool) ->
              (bool) ->
                (bool) -> (bool) -> (bool) -> (bool) -> (bool) -> ascii.

Inductive string : U :=
| EmptyString : string
| String : (ascii) -> (string) -> string.

Definition cat :=
  ((fix cat s1 s2 =>
      match s1 with
      | EmptyString => s2
      | (String c s1) => (String c ((cat) s1) s2)
      end) :
    (string) -> (string) -> string).

Import stdout 2 as _stdout_.

Inductive ref_msg : U :=
| GET : ref_msg
| SET : ref_msg
| FREE : ref_msg.

Definition ref_t :=
  ((fix ref_t A =>
      ?(msg : ref_msg),
        match msg with
        | GET => !(_ : A), (ref_t) A
        | SET => ?(_ : A), (ref_t) A
        | FREE => $
        end) :
    (U) -> proto).

Definition ref_handler :=
  ((fix ref_handler A m =>
      lin ch =>
        match recv ch with
        | (sig_intro msg ch) =>
          (match msg as x return
             (channel match x with
                      | GET => !(_ : A), (ref_t) A
                      | SET => ?(_ : A), (ref_t) A
                      | FREE => $
                      end) ->
               unit
           with
           | GET =>
             fun ch => let ch := (send ch) m in (((ref_handler) A) m) ch
           | SET =>
             fun ch =>
               match recv ch with
               | (sig_intro m ch) => (((ref_handler) A) m) ch
               end
           | FREE => fun ch => close ch
           end) ch
        end) :
    forall (A : U), (A) -> (channel (ref_t) A) -o unit).

Definition mk_ref :=
  ((fun A m x =>
      fork (ref : channel (ref_t) A) := x in (((ref_handler) A) m) ref) :
    forall (A : U), (A) -> (main) -> (tnsr channel ~(ref_t) A main)).

Definition set_ref :=
  ((fun A m => lin ref => let ref := (send ref) SET in (send ref) m) :
    forall (A : U), (A) -> (channel ~(ref_t) A) -o channel ~(ref_t) A).

Definition get_ref :=
  ((fun A => lin ref => let ref := (send ref) GET in recv ref) :
    forall (A : U),
      (channel ~(ref_t) A) -o (sig A fun _ => channel ~(ref_t) A)).

Definition free_ref :=
  ((fun A =>
      lin ref =>
        let ref := (send ref) FREE in match close ref with
                                      | tt => tt
                                      end) :
    forall (A : U), (channel ~(ref_t) A) -o unit).

Definition Main :=
  match (((mk_ref) string) "hello\n") _main_ with
  | (tnsr_intro ref _main_) =>
    match ((get_ref) string) ref with
    | (sig_intro msg1 ref) =>
      let ref := (((set_ref) string) "world\n") ref in
      match ((get_ref) string) ref with
      | (sig_intro msg2 ref) =>
        let _stdout_ := (send _stdout_) msg1 in
        let _stdout_ := (send _stdout_) msg2 in
        match ((free_ref) string) ref with
        | tt => match close _stdout_ with
                | tt => _main_
                end
        end
      end
    end
  end.

--------------------------------------------------------------------------------
tcheck ok
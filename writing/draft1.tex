% document layout
\documentclass{article}
\usepackage[margin=1.2in]{geometry}
\usepackage[utf8]{inputenc}

% packages
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mdwtab}
\usepackage{syntax}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{float}
\usepackage{tikz-cd}

\floatstyle{plain} 
\restylefloat{figure}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\renewcommand{\syntleft}{}
\renewcommand{\syntright}{}
\setlength{\grammarparsep}{10pt}
\setlength{\grammarindent}{10em}
\newcommand{\indalt}[1][2]{\\\hspace*{-1.2em}\textbar\quad}
\newcommand{\rname}[1]{\textsc{\footnotesize #1}}
\newcommand{\LNLD}{\text{LNL}_\text{D}}
\newcommand{\ok}{\textbf{ok}}
\newcommand{\pure}[1]{|#1|}
\newcommand{\sort}{\textbf{sort}}
\newcommand{\type}{\textbf{type}}
\newcommand{\refl}{\text{refl}}
\newcommand{\letin}[3]{$\text{let }#1\text{ := }#2\text{ in }#3$}
\newcommand{\new}{\text{new}}
\newcommand{\free}{\text{free}}
\newcommand{\get}{\text{get}}
\newcommand{\set}{\text{set}}
\newcommand{\subst}{\text{subst}}
\newcommand{\utype}{:_{\scriptscriptstyle U}}
\newcommand{\ltype}{:_{\scriptscriptstyle L}}
\newcommand{\stype}[1]{:_#1}
\newcommand{\step}{\leadsto}
\newcommand{\pstep}{\leadsto}
\newcommand{\mrg}[3]{#1\ddagger#2\ddagger#3}
\newcommand{\arw}[2]
{\hspace*{0.2em}{\scriptstyle #1}\hspace*{-0.2em}
\rightarrow
\hspace*{-0.2em}{\scriptstyle #2}\hspace*{0.2em}}
\newcommand{\erase}[1]{\llbracket #1 \rrbracket}

% title and author
\title{The Calculus of Linear Constructions}
\author{Qiancheng Fu}

% document body
\begin{document}
  \maketitle 
  \begin{abstract}
    The Calculus of Linear Constructions (CLC) is an extension of the Calculus of Constructions (CC) with linear types. Specifically, CLC extends CC with a hierarchy of linear universes, and an indexed typing judgment that precisely controls the weakening and contraction of its term level inhabitants. We study the meta-theory of CLC, showing that it is a sound logical framework for reasoning about resource. CLC is backwards compatible with CC, allowing CLC to enjoy the fruits of decades of CC research. We have formalized and proven correct all major results of the core calculus in the Coq Proof Assistant. We extend CLC with linear inductive types and show that CLC as a programming language enables the manipulation of mutable data structures in a principled way.
  \end{abstract}

  \section{Introduction}
  The Calculus of Constructions (CC) is a dependent type theory introduced by Coquand, and Huet in their landmark work \cite{cc}. In CC types can depend on terms, allowing one to write precise specifications as types. Today, CC and its variations CIC \cite{cic} and ECC \cite{ecc} lie at the core of popular proof assistants such as Coq \cite{coq}, Agda \cite{agda}, Lean \cite{lean}, and others. These theorem provers have found great success in the fields of software verification \cite{compcert,deepspec}, and constructive mathematics \cite{four-color,schemes}. 
  
  However, due to its origins as a logical framework for constructive mathematics, it is quite difficult for CC to encode and reason about resources. Intuitively, a mathematical theorem can be applied an unrestricted number of times. Comparatively, the usage of resources is more limited. For example, if we encode Girard's classical example \cite{girard95} of purchasing cigarettes literally into CC as a function of type:
  \begin{equation*}
    Money \rightarrow Camels + Marlboro
  \end{equation*}
  If viewed as an propositional implication, the customer will still maintain full ownership of their money after paying the vendor, because implication does not diminish the validity of its antecedent. Unless the vendor is exceedingly generous, we are faced with the crime of counterfeiting. Users of proof assistants based on CC often need to embed external logics \cite{bedrock} to provide additional reasoning principles for dealing with resource. The design and embedding of these logics is a difficult problem in its own right, requiring additional proofs to justify its soundness. We propose an alternative solution: extend CC with linear types.

  Linear Logic is a substructural logic introduced by Girard in his seminal work \cite{girard}. Girard notice that the weakening and contraction rules of Classical Logic when restricted carefully, gives rise to a new logical foundation for reasoning about resource. Wadler \cite{wadler1990,wadler1991} first notice that an analogous restriction to variable usage in simple type theory leads to a linear type theory, where terms respect resources. A term calculus for linear type theory was later realized by Abramsky \cite{abramsky1993}. Benton \cite{benton1994} investigates the ramifications of the ! exponential in linear term calculi, decomposing it to adjoint connectives $F$ and $G$ that map between linear and non-linear judgments. Programming languages \cite{l3,ats,linear-haskell} featuring linear types have also been implemented, allowing programmers to write resource safe software in practical applications. The success of integrating Linear Logic with simple type theory exposes a tantalizing new frontier of integrating linearity with richer type theories.

  Work have been done to extend dependent type theories with linear types. Cervesato and Pfenning extends the Edinburgh Logical Framework with linear types \cite{lf,llf}, being the first to demonstrate that dependent types and linear types can coexist within a type theory. V\'{a}k\'{a}r \cite{vakar14} gives a categorical semantics for linear dependent types.  Krishnaswami et al. present a dependent linear type theory \cite{neel15} based on Benton's early work of mixed linear and non-linear calculus, demonstrating the ability to internalize imperative programming the style of Hoare Type Theory \cite{htt}. Luo et al. introduce the property of essential linearity, and a mixed linear/non-linear context, describing the first type theory that allows types to depend on linear terms. Based on initial ideas of McBride \cite{nothing}, Atkey's Quantitative Type Theory (QTT) \cite{qtt} uses semi-ring annotations to track variable occurrence, simulating irrelevance, linear, and affine types within a unified framework. The Idris 2 programming language \cite{idris2} implements QTT as its core type system.

  We propose a new linear dependent type system - The Calculus of Linear Constructions (CLC). CLC extends CC$\omega$ with linear types. CC$\omega$ itself is an extension of CC with a cumulative hierarchy of type universes. We add extra universes $L$ of linear types with cumulativity parallel to the universes $U$ of non-linear types. Universe information is propagated by an indexed typing judgment down to the term level, controlling the usage of weakening and contraction rules. This ultimately results in the \textit{linearity} theorem, stating that all resources are used exactly once.

  The presence of both linear and dependent types enables CLC to write specifications that faithfully encodes the usage of resource. The previous example of monetary transaction can be refined using an indexed linear type family $Money : \mathbb{N} \rightarrow L$ as follows.
  \begin{equation*}
    (Money\ 5) \arw{L}{L} (Camels + Marlboro)
  \end{equation*}
  This new specification for transaction states that it requires a payment of 5 units of money, the customer is relieved of their ownership after the transaction finishes, effectively preventing the contradiction of having your cake and eating it too.

  Compared to preexisting approaches for integrating linear types and dependent types, CLC offers a ``lightweight'' approach to extending CC$\omega$ with linear types, akin to Mazurak et al.'s work on System F \cite{mazurak}. This allows for a straightforward modeling of CLC in CC$\omega$, and lifting of CC$\omega$ into CLC, endowing CLC with the fruits of decades of CC research. We further extend CLC with inductive types, showing that as a programming language it can manipulate mutable data structures in a principled way. We have formalized all major results in Coq, and implemented a prototype in OCaml. 

  \medskip

  \noindent \textbf{\textit{Contributions}}: 
  Our contributions can be summarized as follows.
  \begin{itemize}
    \item Fist, we describe the Calculus of Linear Constructions, an extension to the Calculus of Constructions with linear types. The integration of linear types and dependent types allows CLC to directly and precisely reason about resource.
    \item Next, we study the meta-theory of CLC directly, showing that it satisfies the standard properties of confluence, regularity, and subject reduction. 
    \item We observe that CLC is highly backwards compatible with CC$\omega$. We construct a reduction preserving model of CLC in CC$\omega$, showing that CLC is consistent. 
    \item All major results have been formalized and proven correct in the Coq Proof Assistant with help from the Autosubst \cite{autosubst} library. To the best of our knowledge, our development is the first machine checked formalization of a linear dependent type theory.
    \item Furthermore, we extend CLC with linear inductive data, demonstrating that as a programming language, CLC can safely manipulate mutable data structures.
    \item Finally, we give an implementation extended with user definable linear and non-linear inductive types. Algorithmic type checking employed by the implementation streamlines the process of writing CLC.
  \end{itemize}

  \section{The Language of CLC}
  \subsection{Syntax}
  The syntax of the core type theory is presented in Figure \ref{syntax}. Our type theory contains two sorts of universes $U$ and $L$. We use the meta variable $k$ to specifically quantify over levels $0, 1, 2, ...$ that correspond to the predicative universes. We use the meta variable $i$ to quantify over all levels $*, 0, 1, 2, ...$. Here, $U_*$ is the impredicative universe of propositions, in the same spirit as CC$\omega$'s $Prop$ universe. $U_k$, and $L_k$ are the predicative universes of non-linear, and linear types respectively.

  \begin{figure}[H]
    \caption{Syntax}
    \centering
    \begin{minipage}{0.8\linewidth}
    \begin{grammar}
      <$k$> := 0 | 1 | 2 ... | \phantom{*} \hspace*{5.8em} predicative levels

      <$i$> := * | 0 | 1 | 2 ... \hspace*{5.8em} all levels

      <$s, t$> ::= $U$ | $L$ \phantom{| $x$} \hspace*{8em} sorts

      <$m, n, A, B, C$> ::= $U_i$ | $L_k$ | $x$ \hspace*{7.3em} expressions
      \indalt $(x : A) \arw{s}{t} B$
      \indalt $\lambda x. n$ | $m\ n$
    \end{grammar}
    \end{minipage}
    \label{syntax}
  \end{figure}
  A clear departure of our language from standard presentations of both linear type theory, and dependent type theory is the indexed function type: $(x : A) \arw{s}{t} B$. The reason for these indices is that we have built the ! exponential of linear logic directly into universe sorts. The indices $s$, and $t$ annotate the domain, and co-domain's respective universe sort, hence annotating linearity. The behavior of ! is difficult to account for even in simple linear type theory. Subtle issues arise if !! is not canonically isomorphic to !, which may invalidate the substitution lemma \cite{substitute}. By integrating the exponential directly into universe sorts, we implicitly limit ! to only be used canonically. This allows us to derive the substitution lemma, and construct a direct modeling of CLC in CC$\omega$ without needing any machinery for manipulating exponential.
  \begin{figure}[H]
    \caption{Correspondence of CLC types and MELL implications}
    \begin{align}
      (\_ : A) \arw{U}{U} B \quad &\equiv \quad !A \multimap !B \\
      (\_ : A) \arw{U}{L} B \quad &\equiv \quad !A \multimap B \\
      (\_ : A) \arw{L}{U} B \quad &\equiv \quad A \multimap !B \\
      (\_ : A) \arw{L}{L} B \quad &\equiv \quad A \multimap B
    \end{align}
    \label{correspondence}
  \end{figure}
  Figure \ref{correspondence} illustrates the correspondence between CLC function types and Multiplicative Exponential Linear Logic (MELL) implications. MELL lacks counterparts for the cases (1), (2) if the co-domain $B$ is dependent on arguments of domain $A$. Though it may seem as if implications of the $!(A \multimap B)$ form are left out, CLC encodes these by endowing each function type with a universe sort through their formation judgment. The encoding for this example would be $\Gamma \vdash A \arw{L}{L} B \utype U_i $. We will discuss function type formation in Section \ref{tyformation} in greater detail.

  In practice, algorithmic type checking techniques such as bi-directional typing allow users to omit writing most of these sort indices.

  \subsection{Universes and Cumulativity}
  CLC features two sorts of universes $U$, and $L$ with level indices $*, 0, 1, 2, \cdots$. $U_*$ is the impredicative universe of propositions. $U_k$, and $L_k$ are the predicative universe of non-linear types, and linear types respectively. The main mechanism that CLC uses to distinguish between linear and non-linear types is by checking the universe to which they belong. Basically, terms with types that occur within $U_i$ are unrestricted in their usage. Terms with types that occur within $L_k$ are restricted to being used exactly once.

  In order to lift terms from lower universes to higher ones, there exists cumulativity between universe levels of the same sort. We define cumulativity as follows.

  \begin{definition}
    The cumulativity relation ($\preceq$) is the smallest binary relation over terms such that
    \begin{enumerate}
      \item $\preceq$ is a partial order with respect to definitional equality.
        \begin{enumerate}
          \item If $A \equiv B$, then $A \preceq B$.
          \item If $A \preceq B$ and $B \preceq A$, then $A \equiv B$.
          \item If $A \preceq B$ and $B \preceq C$, then $A \preceq B$.
        \end{enumerate}
      \item $U_* \preceq U_0 \preceq U_1 \preceq U_2 \preceq \cdots$
      \item $L_0 \preceq L_1 \preceq L_2 \preceq \cdots$
      \item If $A_1 \equiv A_2$ and $B_1 \preceq B_2$, then
        $(x : A_1) \arw{s}{t} B_1 \preceq (x : A_2) \arw{s}{t} B_2$
    \end{enumerate}
  \end{definition}

  Figure \ref{universe} illustrates the structure of our universe hierarchy. Each linear universe $L_k$ has $U_{k+1}$ as its type, allowing functions to freely quantify over linear \textit{types}. However, $L_k$ cumulates to $L_{k+1}$. These two parallel threads of cumulativity prevent linear types from being transported to the non-linear universe, and subsequently losing track of its occupants' linearity.

  \begin{figure}[H]
    \caption{The Universe Hierarchy}
    \centering
    \begin{tikzcd}
      U_* \arrow[r, ":"', "\preceq", dash] 
      & U_0 \arrow[r, ":"', "\preceq", dash] 
      & U_1 \arrow[r, ":"', "\preceq", dash] 
      & U_2 \arrow[r, ":"', "\preceq", dash] 
      & \cdots \\
      & L_0 \arrow[r, "\preceq" description, dash] \arrow[ru, ":" description, dash] 
      & L_1 \arrow[r, "\preceq" description, dash] \arrow[ru, ":" description, dash] 
      & L_2 \arrow[r, "\preceq" description, dash] \arrow[ru, ":" description, dash] 
      & \cdots
    \end{tikzcd}
    \label{universe}
  \end{figure}

  \subsection{Context and Structural Judgments}
  The context of our language employs a mixed linear/non-linear representation in the style of Luo\cite{luo}. Variables in the context are annotated to indicate whether they are linear or non-linear. A non-linear variable is annotated as $\Gamma, x \utype A$, whereas a linear variable is annotated as $\Gamma, x \ltype A$. 
  
  Next, we define a $\mrg{\Gamma_1}{\Gamma_2}{\Gamma}$ relation that merges two mixed contexts $\Gamma_1$, and $\Gamma_2$ into $\Gamma$, by performing contraction on shared non-linear variables. For linear variables, the $\mrg{\_}{\_}{\_}$ relation is defined if and only if each variable occurs uniquely in one context and not the other. This definition of $\mrg{\_}{\_}{\_}$ is what allows contraction for non-linear variables whilst forbidding it for linear ones.

  An auxiliary judgment $\pure{\Gamma}$ is defined to assert that a context $\Gamma$ does not contain linear variables. In other words, all variables found in $\pure{\Gamma}$ are annotated of the form $x \utype A$. The full rules for structural judgments are presented in Figure \ref{structural}.
  
  \begin{figure}[H]
    \caption{Structural Judgments}
    \begin{mathpar}
      \inferrule
      { }
      { \epsilon \vdash }
      \rname{Wf-$\epsilon$}

      \inferrule
      { \Gamma\ \vdash \\ 
        \overline{\Gamma} \vdash A \utype U_i }
      { \Gamma, x \utype A \vdash }
      \rname{Wf-U}

      \inferrule
      { \Gamma\ \vdash \\ 
        \overline{\Gamma} \vdash A \utype L_k }
      { \Gamma, x \ltype A\ \vdash } 
      \rname{Wf-L}
      \\

      \inferrule
      { }
      { \pure{\epsilon} }
      \rname{Pure-$\epsilon$}

      \inferrule
      { \pure{\Gamma} \\
        \Gamma \vdash A \utype U }
      { \pure{\Gamma, x \utype A} }
      \rname{Pure-U}
      \\

      \inferrule
      { }
      { \mrg{\epsilon}{\epsilon}{\epsilon} }
      \rname{Merge-$\epsilon$}

      \inferrule
      { \mrg{\Gamma_1}{\Gamma_2}{\Gamma} }
      { \mrg{\Gamma_1, x \utype A}
            {\Gamma_2, x \utype A}
            {\Gamma, x \utype A} }
      \rname{Merge-U}

      \inferrule
      { \mrg{\Gamma_1}{\Gamma_2}{\Gamma} \\
        x \notin \Gamma_2 }
      { \mrg{\Gamma_1, x \ltype A}
            {\Gamma_2}
            {\Gamma, x \ltype A} }
      \rname{Merge-L1}

      \inferrule
      { \mrg{\Gamma_1}{\Gamma_2}{\Gamma} \\
        x \notin \Gamma_1 }
      { \mrg{\Gamma_1}
            {\Gamma_2, x \ltype A}
            {\Gamma, x \ltype A} }
      \rname{Merge-L2} 
    \end{mathpar}
    \label{structural}
  \end{figure}

  \begin{definition}
    The context restriction function $\overline{\Gamma}$ is defined as a recursive filter over $\Gamma$ as follows. All linear variables are removed from context $\Gamma$. The result of context restriction is the non-linear subset of the original context.
    \begin{align*}
      \overline{\epsilon} = \epsilon
      \hspace*{4em}
      \overline{\Gamma, x \utype A} = \overline{\Gamma}, x \utype A 
      \hspace*{4em}
      \overline{\Gamma, x \ltype A} = \overline{\Gamma}
    \end{align*}
  \end{definition}

  \subsection{Typing Judgment}
  Typing judgments in CLC take on the form of $\Gamma \vdash m \stype{s} A$. Intuitively, this judgment states that the term $m$ is an inhabitant of type $A$, with free variables typed in $\Gamma$. The sort index $s$ tells us the linearity of $m$. Specifically, if $s = U$, then $m$ has unrestricted usage. Conversely, if $s = L$, then $m$ must be used exactly once. Theorem \ref{regularity} (regularity) shows that $s$ corresponds exactly to the sort of $A$'s universe.

  \begin{definition} We formally define the terms \textit{non-linear}, \textit{linear}, \textit{unrestricted}, and \textit{restricted}.
    \begin{enumerate}
      \item A \textit{type} $A$ is \textit{non-linear} under context $\Gamma$ if $\Gamma \vdash A \utype U_i$.
      \item A \textit{type} $A$ is \textit{linear} under context $\Gamma$ if $\Gamma \vdash A \utype L_k$.
      \item A \textit{term} $m$ is \textit{unrestricted} under context $\Gamma$ if it has type $A$, and $\Gamma \vdash m \utype A$. A unrestricted term may be used an arbitrary number of times.
      \item A \textit{term} $m$ is \textit{restricted} under context $\Gamma$ if it has type $A$, and $\Gamma \vdash m \ltype A$ A restricted term must be used exactly once.
    \end{enumerate}
  \end{definition}

  \subsection{Type Formation} \label{tyformation}
  The rules for forming types are presented in Figure \ref{type}. In CLC, we forbid types from depending on linear terms similar to \cite{llf,neel15} for the same reason of avoiding philosophical troubles.

  \begin{figure}[H]
    \caption{Type Formation} 
    \begin{mathpar}
      \inferrule
      { \pure{\Gamma} }
      { \Gamma \vdash U_* \utype U_0 } 
      \rname{Prop-Axiom}

      \inferrule
      { \pure{\Gamma} }
      { \Gamma \vdash U_k \utype U_{k+1} } 
      \rname{U-Axiom}

      \inferrule
      { \pure{\Gamma} }
      { \Gamma \vdash L_k \utype U_{k+1} } 
      \rname{L-Axiom}
      \\

      \inferrule
      { \pure{\Gamma} \\
        \Gamma \vdash A \utype U_i \\ 
        \Gamma, x \utype A \vdash B \utype U_* }
      { \Gamma \vdash (x : A) \arw{U}{U} B \utype U_* } 
      \rname{U-Prop}
      \\

      \inferrule
      { \pure{\Gamma} \\
        \Gamma \vdash A \utype U_k \\ 
        \Gamma, x \utype A \vdash B \utype s_k }
      { \Gamma \vdash (x : A) \arw{U}{s} B \utype t_k } 
      \rname{U-Prod}

      \inferrule
      { \pure{\Gamma} \\
        \Gamma \vdash A \utype L_k \\ 
        \Gamma \vdash B \utype s_k \\
        x \notin \Gamma }
      { \Gamma \vdash (x : A) \arw{L}{s} B \utype t_k } 
      \rname{L-Prod}
    \end{mathpar}
    \label{type}
  \end{figure}

  The axiom rules \rname{Prop-Axiom}, \rname{U-Axiom}, \rname{L-Axiom} are almost standard, the main difference being the extra side-condition of judgment $\pure{\Gamma}$. In most presentations of dependent type theories without linear types, the universe axioms are derivable under any well-formed context $\Gamma$. Variables not pertaining to actual proofs could be introduced this way, thus giving rise to the admissibility of weakening. To support linear types, we must restrict weakening to non-linear variables. This justifies the restriction of $\Gamma$ to contain only non-linear variables for \rname{Prop-Axiom}, \rname{U-Axiom}, \rname{L-Axiom}. From \rname{L-Axiom} we can see that the universe of linear types $L_k$ is an inhabitant of $U_{k+1}$. This is reminiscent of Krishnaswami et al.'s treatment of linear universes \cite{neel15}, where linear \textit{types} themselves can be used unrestrictedly.

  The \rname{U-Prop} rule is used for forming propositions. From the judgment $\Gamma \vdash A \utype U_i$ we can see that \rname{U-Prop} allows for quantification over non-linear types of arbitrary level, hence impredicative. The judgment $\Gamma, x \utype A \vdash B \utype U_*$ asserts that the co-domain must be in the impredicative universe $U_*$. The final resulting judgment $\Gamma \vdash (x : A) \arw{U}{U} B \utype U_*$ is indexed by $U$, indicating that the \textit{type} $(x : A) \arw{U}{U} B$ can be use unrestrictedly as a \textit{term}. Since $(x : A) \arw{U}{U} B$ belongs to universe $U_*$, its \textit{terms} also enjoys unrestricted usage.

  The \rname{U-Prod} rule is used for forming function types with non-linear domains. This is evident from the judgment $\Gamma \vdash A \utype U_k$. Since $A$ is in the predicative non-linear universe $U_k$, terms of type $A$ have unrestricted usage. The non-linearity of domain $A$ allows $B$ to depend on terms of type $A$, as seen in judgment $\Gamma, x \utype A \vdash B \utype s_k$. The domain $B$ itself may be non-linear or linear, since $B$'s universe $s_k$ can vary between $U_k$ and $L_k$. From the resulting judgment $\Gamma \vdash (x : A) \arw{U}{s} B \utype t_k$, we see that $A$, and $B$'s universe sorts are used as indices to the arrow. Interestingly, $(x : A) \arw{U}{s} B$ is assigned to a universe $t_k$ of level $k$ and arbitrary sort $t$. If $t$ is chosen to be $U$, then $\Gamma \vdash (x : A) \arw{U}{s} B \utype U_k$ tells us $\lambda$-abstractions of this type have unrestricted usage. Conversely, if $t$ is chose to be $L$, then $\Gamma \vdash (x : A) \arw{U}{s} B \utype L_k$ tells us $\lambda$-abstractions of this type have restricted usage. This is how we encode the missing $!(A \multimap B)$ forms from MELL shown in Figure \ref{correspondence}.

  The \rname{L-Prod} rule is used for forming function types with linear domains. From the judgment $\Gamma \vdash A \utype L_k$, we see that $A$ is a linear type, and terms of type $A$ have restricted usage. Because of this, we forbid co-domain $B$ from depending on terms of type $A$, evident in the judgment $\Gamma \vdash B \utype s_k$. Like \rname{U-Prod}, co-domain $B$ itself may be non-linear or linear, since $B$'s universe $s_k$ can vary between $U_k$ and $L_k$. The final resulting judgment is $\Gamma \vdash (x : A) \arw{L}{s} B \utype t_k$. Here, $x$ is a hypocritical unbinding variable whose only purpose is to preserve syntax uniformity. Again, we may chose $t$ to be either $U$ or $L$, which form function types for $\lambda$-abstractions with unrestricted or restricted usage respectively.

  For rules \rname{U-Prod}, and \rname{L-Prod}, it may seem as if the final choice of $t_k$ does not matter. Indeed, the choice of $t = U$ or $t = L$ has no effect on type formation. But the differences will become apparent when typing $\lambda$-abstractions in Section \ref{teformation}. 

  \subsection{Term Formation} \label{teformation}
  The rules for term formation are presented in Figure \ref{term}.

  \begin{figure}[H]
    \caption{Term Formation}
    \begin{mathpar}
      \inferrule
      { \pure{\Gamma} }
      { \Gamma, x \utype A \vdash x \utype A } 
      \rname{U-Var}

      \inferrule
      { \pure{\Gamma} }
      { \Gamma, x \ltype A \vdash x \ltype A } 
      \rname{L-Var}
      \\

      \inferrule
      { \pure{\Gamma} \\
        \Gamma \vdash (x : A) \arw{s}{t} B \utype U_i \\ 
        \Gamma, x \stype{s} A \vdash n \stype{t} B }
      { \Gamma \vdash \lambda x . n \utype (x : A) \arw{s}{t} B }
      \rname{U-$\lambda$}
      \\

      \inferrule
      { \overline{\Gamma} \vdash (x : A) \arw{s}{t} B \utype L_k \\ 
        \Gamma, x \stype{s} A \vdash n \stype{t} B }
      { \Gamma \vdash \lambda x . n \ltype (x : A) \arw{s}{t} B }
      \rname{L-$\lambda$}
      \\

      \inferrule
      { \Gamma_1 \vdash m \stype{t} (x : A) \arw{U}{s} B \\
        \pure{\Gamma_2} \\
        \Gamma_2 \vdash n \utype A \\
        \mrg{\Gamma_1}{\Gamma_2}{\Gamma} }
      { \Gamma \vdash m\ n \stype{s} B[n/x] }
      \rname{U-App}
      \\

      \inferrule
      { \Gamma_1 \vdash m \stype{t} (x : A) \arw{L}{s} B \\
        \Gamma_2 \vdash n \ltype A \\
        \mrg{\Gamma_1}{\Gamma_2}{\Gamma} }
      { \Gamma \vdash m\ n \stype{s} B[n/x] }
      \rname{L-App} 
      \\

      \inferrule
      { \Gamma \vdash m \stype{s} A \\
        \overline{\Gamma} \vdash B \utype s_i \\ A \preceq B }
      { \Gamma \vdash m \stype{s} B } 
      \rname{Conv}
    \end{mathpar}
    \label{term}
  \end{figure}

  The rules \rname{U-Var}, and \rname{L-Var} are used for typing free variables. The \rname{U-Var} rule asserts that free variable $x$ occurs within the context $\Gamma, x \utype A$ with a non-linear type $A$. The \rname{L-Var} rule asserts that free variable $x$ occurs within the context $\Gamma, x \ltype A$ with linear type $A$. For both rules, the side condition $\pure{\Gamma}$ forbids irrelevant variables with linear type from occurring within $\Gamma$. This prevents weakening variables with linear type.

  As promised in Section \ref{tyformation}, the choice of $t_k$ for function type formation comes into play during the typing of $\lambda$-abstractions. Namely, in the pair of rules \rname{U-$\lambda$}, and \rname{L-$\lambda$}.

  By design, types with universe sort $U$ are non-linear, terms with these types enjoy unrestricted usage. In \rname{U-$\lambda$}, the function type being addressed has universe $U_i$, as seen by the judgment $\Gamma \vdash (x : A) \arw{s}{t} \utype U_i$. $\lambda$-abstractions of this type can be applied an unrestricted number of times, hence cannot depend on free variables with restricted usage. This consideration is realized by the side condition $\pure{\Gamma}$, asserting all variables in context $\Gamma$ are unrestricted. Next, the body of the abstraction $n$ is typed as $\Gamma, x \stype{s} A \vdash n \stype{t} B$, where $s$ is the sort of $A$ and $t$ is the sort of $B$. Finally, the resulting judgment $\Gamma \vdash \lambda x.n \utype (x : A) \arw{s}{t} B$ with index $U$, asserts that the $\lambda$-abstraction can be used unrestrictedly.

  In contrast to \rname{U-$\lambda$}, the \rname{L-$\lambda$} rule is used for forming $\lambda$-abstractions that must be used exactly once. Since these abstractions must be used once, they are allowed access to restricted variables within context $\Gamma$, evident in the judgment $\Gamma, x \stype{s} A \vdash n \stype{t} B$, and lack of side condition $\pure{\Gamma}$. However, in judgment $\overline{\Gamma} \vdash (x : A) \arw{s}{t} B \utype L_k$ the context must be filtered, since types are not allowed to depend on restricted variables. The final resulting judgment $\Gamma \vdash \lambda x.n \ltype (x : A) \arw{s}{t} B$ with index $L$, asserts that the $\lambda$-abstraction must be used exactly once.
  
  For \rname{U-App}, domain $A$ is a non-linear type, as seen by its arrow index in $(x : A) \arw{U}{s} B$. Intuitively, this tells us that $x$ may be used an arbitrary number of times within the body of $m$. Thus, the supplied argument $n$ must not depend on restricted variables in context $\Gamma_2$. Otherwise, substitution may put multiple copies of $n$ into $m$ during $\beta$-reduction, duplicating variables that should have been restricted. This justifies the side condition of $\pure{\Gamma_2}$. The contexts $\Gamma_1$, and $\Gamma_2$ are finally merged together into $\Gamma$ by the relation $\mrg{\Gamma_1}{\Gamma_2}{\Gamma}$, contracting all unrestricted variables shared between $\Gamma_1$, and $\Gamma_2$.
  
  Now for \rname{L-App}, domain $A$ is a linear type, as seen by its arrow index in $(x : A) \arw{L}{s} B$. Intuitively, this tells us that $x$ must be used once within the body of $m$. During $\beta$-reduction, substitution will only put a single copy of $n$ into the body of $m$, so $n$ can depend on restricted variables within $\Gamma_2$ without fear of duplicating them. This justifies the lack of side condition $\pure{\Gamma_2}$. The contexts $\Gamma_1$, and $\Gamma_2$ are finally merged together into $\Gamma$ by the relation $\mrg{\Gamma_1}{\Gamma_2}{\Gamma}$, contracting all unrestricted variables shared between $\Gamma_1$, and $\Gamma_2$.

  Finally, the \rname{Conv} rule allows judgment $\Gamma \vdash m \stype{s} A$ to convert to judgment $\Gamma \vdash m \stype{s} B$, if $B$ is a valid type in context $\overline{\Gamma}$, and of the same sort $s$ as $A$. Futhermore, $A$ must be a subtype of $B$ satisfying the cumulativity relation $A \preceq B$. This rule gives rise to large eliminations, as computations embedded at the type level can convert to canonical types.


  \subsection{Equality and Parallel Reduction} \label{reduction}
  The operational semantics, and definitional equality of CLC is defined by parallel reductions \cite{takahashi}. The reduction, and equality rules for CLC are presented in Figure \ref{parallel}, and are entirely standard.
  \begin{figure}[H]
    \caption{Equality and Parallel Reduction}
    \begin{mathpar}
      \inferrule
      { m_1 \pstep^* n \\ m_2 \pstep^* n }
      { m_1 \equiv m_2 : A }
      \rname{Join}

      \inferrule
      { }
      { x \pstep x }
      \rname{P-Var}

      \inferrule
      { }
      { U \pstep U }
      \rname{P-U}

      \inferrule
      { }
      { L \pstep L }
      \rname{P-L}

      \inferrule
      { n \pstep n' }
      { \lambda x.n \pstep \lambda x.n' }
      \rname{P-$\lambda$}

      \inferrule
      { m \pstep m' \\ n \pstep n' }
      { m\ n \pstep m'\ n' }
      \rname{P-App}

      \inferrule
      { m \pstep m' \\ n \pstep n' }
      { (\lambda x.m)\ n \pstep m'[n'/x] }
      \rname{P-$\beta$}

      \inferrule
      { A \pstep A' \\ B \pstep B' }
      { (x : A) \arw{s}{t} B \pstep (x : A') \arw{s}{t} B' }
      \rname{P-Prod}
    \end{mathpar}
    \label{parallel}
  \end{figure}
  As we have discussed previously, the elimination of the explicit ! exponential allows CLC to maintain a simple operational semantics, whose $\beta$-reductions are very well behaved.

  \subsection{Meta Theory} \label{meta}
  In this section, we focus our discussion on the meta-properties of CLC. First, we show the type soundness of CLC through the \textit{subject reduction} theorem. Next, we show that CLC is a valid linear type theory through the \textit{linearity} theorem. Finally, we construct a reduction preserving erasure function that maps well-typed CLC terms to well-typed CC$\omega$ terms, showing that CLC is strongly normalizing.
  
  All proofs have been formalized in Coq with help from the Autosubst \cite{autosubst} library. The Coq development is publicly available on the first author's Github repository. To the best of our knowledge, this is the first machined checked formalization of a linear dependently type theory. We given a hand written version of the proof in the appendix as well.

  \subsubsection{Reduction and Confluence}

  The following lemmas and proofs are entirely standard. The presence of linear types do not pose any complications as reductions are untyped.

  \begin{lemma} Parallel reduction satisfies the diamond property. \\
    If $m \pstep m_1$ and $m \pstep m_2$ then there exists $m'$ such that $m_1 \pstep m'$ and $m_2 \pstep m'$.
  \end{lemma}

  \begin{corollary} The transitive reflexive closure of parallel reduction is confluent. \\ 
    If $m \pstep^* m_1$ and $m \pstep^* m_2$ then there exists $m'$ such that $m_1 \pstep^* m'$ and $m_2 \pstep^* m'$.
  \end{corollary}

  \begin{corollary}
    The definitional equality relation $\equiv$ is an equivalence relation.
  \end{corollary}

  \subsubsection{Weakening} \label{subst}
  CLC restricts the weakening rule for variables of linear types. However, weakening variables of non-linear types remain admissible.

  \begin{lemma} Weakening. \\
    If $\Gamma \vdash m \stype{s} A$ is a valid, then for any $x \notin \Gamma$, judgment $\Gamma, x \utype B \vdash m \stype{s} A$ is derivable.
  \end{lemma}

  \subsubsection{Substitution} \label{subst}
  Though the substitution lemma is widely considered a boring and bureaucratic theorem, it is surprisingly hard to design linear typed languages where the substitution lemma is admissible. Much of this difficulty arise during the substitution of arguments containing ! exponential. Perhaps the most famous work detailing the issues of substitution is due to Wadler \cite{substitute}. He defines additional syntax, and semantics for the intricate unboxing of ! terms, solving the lack of substitute in Abramsky's term calculus \cite{abramsky1993}.

  Our design of integrating ! into universe sorts removes the need for ! manipulating syntax, and semantics. The substitution lemma is directly proved by induction on typing derivations.

  \begin{lemma} Substitution. \\
    For $\Gamma_1, x \stype{s} A \vdash m \stype{t} B$ and $\Gamma_2 \vdash v \stype{s} A$, if $\mrg{\Gamma_1}{\Gamma_2}{\Gamma}$ is defined for some $\Gamma$, then $\Gamma \vdash [v/x]m \stype{t} [v/x]B$.
  \end{lemma}

  \subsubsection{Type Soundness}
  In order to prove subject reduction, we first prove the regularity theorem. The main purpose of regularity is to lower types down to the term level, enabling the application of various inversion lemmas. Regularity also serves a second purpose, it tells us the judgment index $s$ of a term $\Gamma \vdash m \stype{s} A$ is exactly the same sort as its type's universe $\overline{\Gamma} \vdash A \utype s_i$.

  \begin{theorem} Regularity. \\
     For any context $\Gamma$, term $m$, type $A$, and sort $s$, if $\Gamma \vdash m \stype{s} A$ is a valid judgment, then there exists some level $i$ such that $\overline{\Gamma} \vdash A \utype s_i$.
    \label{regularity}
  \end{theorem}

  With weakening, substitution, regularity, and various inversion lemmas proven, subject reduction is proved by induction on typing derivation.

  \begin{theorem} Subject reduction. \\
    For $\Gamma \vdash m \stype{s} A$, if $m \pstep n$ then $\Gamma \vdash n \stype{s} A$.
  \end{theorem}

  \subsubsection{Linearity}
  At this point, we have proven that CLC is type sound. However, we still need to prove that the removal of weakening, and contraction for restricted variables yield tangible impact on the structure of terms. For this purpose, we define a binding aware recursive function $occurs(x, m)$ that counts the number of times variable $x$ appears within term $m$. The linearity theorem asserts that restricted variables are used exactly once within a term, subsuming safe resource usage.

  Before we proceed, we first prove the seemingly obvious narity lemma. 

  \begin{lemma} Narity. \\
    If $\Gamma \vdash m \stype{s} A$ is a valid judgment, for any $x \notin \Gamma$, there is $occurs(x, m) = 0$.
  \end{lemma}

  For cases with branched syntax in the linearity theorem, such as application $(m\ n)$, the $occurs$ function sums up the occurrences of variable $x$ in branches $m$, and $n$. The narity lemma is used to prove that either $occurs(x, m) = 1 \wedge occurs(x, n) = 0$ or $occurs(x, m) = 0 \wedge occurs(x, n) = 1$ is true.

  \begin{theorem} Linearity. \\
    If $\Gamma \vdash m \stype{s} A$ is a valid judgment, for any $(x \ltype B) \in \Gamma$, there is $occurs(x, m) = 1$.
  \end{theorem}

  \subsubsection{Strong Normalization}
  The strong normalization theorem of CLC is proven by construction of a typing, and reduction preserving erasure function to CC$\omega$. We assume familiarity with CC$\omega$ syntax here, and define the erasure function as follows.

  \begin{definition}
    \begin{align*}
      \erase{x} &= x \\
      \erase{U_*} &= Prop \\
      \erase{U_k} &= Type_k \\
      \erase{L_k} &= Type_k \\
      \erase{(x : A) \arw{s}{t} B} &= (x : \erase{A}) \rightarrow \erase{B} \\
      \erase{\lambda x.n} &= \lambda x.\erase{n} \\
      \erase{m\ n} &= \erase{m}\ \erase{n}
    \end{align*}
  \end{definition}

  With slight overloading of notation, we define erasure for CLC contexts recursively.

  \begin{definition}
    \begin{align*}
      \erase{\epsilon} &= \epsilon \\
      \erase{\Gamma, x \stype{s} A} &= \erase{\Gamma}, x : \erase{A}
    \end{align*}
  \end{definition}

  We prove the following lemma to commute erasure and substitution whenever needed.
  \begin{lemma} Erasure commutes with substitution. \\ 
    For any CLC terms $m$, $n$, and some variable $x$, $\erase{m[n/x]} = \erase{m}[\erase{n}/x]$. 
  \end{lemma}

  For the following theorem, we refer to the reductions in CLC as $\pstep_{\scriptscriptstyle \text{CLC}}$, and the reductions in CC$\omega$ as $\pstep_{\scriptscriptstyle \text{CC$\omega$}}$.
  \begin{theorem} \label{preserve} Erasure preserves reduction. \\
    For any CLC terms $m$, and $n$, if there is $m \pstep_{\scriptscriptstyle \text{CLC}} n$, then there is $\erase{m} \pstep_{\scriptscriptstyle \text{CC$\omega$}} \erase{n}$.
  \end{theorem}

  \begin{theorem} \label{embedding} Embedding. \\
    For any CLC context $\Gamma$, terms $m$, $A$, and sort $s$, if $\Gamma \vdash m \stype{s} A$ is a valid typing judgment in CLC, then $\erase{\Gamma} \vdash \erase{m} : \erase{A}$ is a valid a typing judgment in CC$\omega$.
  \end{theorem}

  If there exists some well typed CLC term with an infinite sequence of reductions, erasure will embed this term into a well typed CC$\omega$ term along with its infinite sequence of reductions. This is contradictory to the strong normalization property of CC$\omega$, thus this hypothetical term does not exist in CLC.

  \begin{theorem}
    Well-typed CLC terms are strongly normalizing.
  \end{theorem}

  \section{Future Work}
  \section{Conclusion}

\bibliographystyle{acm}
\bibliography{ref}

\end{document}
% document layout
\documentclass{article}
\usepackage[margin=1.4in]{geometry}
\usepackage[utf8]{inputenc}

% packages
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{syntax}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{float}

\floatstyle{boxed} 
\restylefloat{figure}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\renewcommand{\syntleft}{}
\renewcommand{\syntright}{}
\setlength{\grammarparsep}{10pt}
\setlength{\grammarindent}{16em}

\newcommand{\LNLD}{\text{LNL}_\text{D}}
\newcommand{\ok}{\textbf{ok}}
\newcommand{\pure}{\textbf{pure}}
\newcommand{\sort}{\textbf{sort}}
\newcommand{\type}{\textbf{type}}
\newcommand{\U}{\textbf{U}}
\renewcommand{\L}{\textbf{L}}
\newcommand{\pstep}{\leadsto_p}

% title and author
\title{Dependent Linear Type Theory for Resource Aware Certified Programming}
\author{Qiancheng Fu}

% document body
\begin{document}
  \maketitle 
  \begin{abstract}
    TBD
  \end{abstract}

  \section{Introduction}
  In the field of certified programming, it is of paramount importance for the specification language to precisely characterize the behavior of programs. For this reason, dependent type theory enjoys great success as the type level language of specifications is exactly the same as the term level programming language, giving tremendous power and control to specification writing. The verification achievements carried out by proof assistants such as Coq or F* is a testament how much dependent type theory has accomplished. 
  
  Dependent type theory is however, not without its flaws. Due to its origins as a logical foundation for mathematics, dependent type theory lacks facilities to reason about resource, a concept that is largely absent from mathematics but ever present in computer science. Objects in dependent type theory can be freely duplicated or deleted by appealing to the structural contraction and weakening rules, this goes against the conservation principle of resource. Users of dependent type theories are often required to laboriously embed memory models and program logics into type theory to effectively reason about resource. As language designers, we hope to alleviate this shortcoming of dependent type theory.

  In the disparate world of substructural logic, Girard introduces Linear Logic in his seminal work. Linear Logic restricts weakening and contraction rules of classical logic, giving rise to an elegant formal foundation for reasoning about resource. Abramsky and Wadler notice the opportunities presented by Linear Logic for resource aware programming, pioneering the development of simple linear type theory. Linear type theory enforces linearity on variable usage, which conservatively subsumes resource usage. This reduces the problem of resource reasoning to linear type checking. The successful extraction of type theory from Linear Logic offers a tantalizing hint to overcoming the challenges of resource reasoning in dependent type theory: integrate linear types.

  The earliest work on integrating dependent type theory and linear type theory was carried out by Cervesato and Pfenning, extending the Edinburgh LF with linearity. Xi extends DML dependent types with linear types in the ATS programming language. Krishnaswami et al. develop $\LNLD$ based on Benton's LNL calculus for simple linear types, allowing term dependency on its non-linear fragment. The authors of $\LNLD$ demonstrate its capacity for certified imperative programming in the style of L3 and Hoare Type Theory.  Luo et al. introduce the notion of essential linearity, developing the first type theory that allows types to depend on linear terms. Atkey's QTT, based on initial ideas of McBride, neatly reduces dependency and linearity checking to checking constraints defined on semi-rings. Idris 2 is a full blown programming language that implements QTT as its core type system.

  The lack of weakening and contraction rules for linear types present unique difficulties when integrating full spectrum dependent types, often making dependent linear types challenging or unsatisfactory for practical use. $\LNLD$ requires use of explicit modality maps F and G to alternate between its linear and non-linear fragment, computation requiring back and forth applications of F and G quickly explode in complexity. Terms in Luo's type theory are not intrinsically linear, linearity is solely determined by annotations. The unfortunate side-effect of this design choice is that linear computations never return non-linear values, contradicting the intuition of retrieving a non-linear int from a linear reference. QTT faces the same drawbacks as Luo due to linearity being determined by similar semi-ring annotations.
  
  We present a full spectrum dependent linear type theory that provides a more direct approach to enforce linearity, eschewing the use of modality operators or annotations. We believe that linearity is an intrinsic property completely determined by the type of a term. To accomplish this, our type system uses two class of type universes in the style of Krishnaswami, $L$ for linear and $U$ for non-linear. Due to the abandonment of modalities, we use two distinct functions types $(x : A) \rightarrow B$ for non-linear functions and $(x : A) \multimap B$ for linear functions in the style of Pfenning. We formalize an operational semantics and prove the type soundness of our system. To further demonstrate the applications of dependent linear types, we extend our type system with imperative programming features, leveraging both dependency and linearity for internalized certified imperative programming. We augment our soundness theorem to account for these extensions, showing that imperative resources are properly managed. We have implemented a prototype of our language extended with other features for practicality and ergonomics.

  \section{Core Type Theory}

  \begin{figure}[h]
    \caption{Syntax}
    \begin{grammar}
      <$x, y, z, f, g, h$> $\in$ variables

      <$m, n, A, B, C$> $\in$ expressions

      <$v$> $\in$ values

      <expressions> ::= $\U$ | $\L$ | $x$
      \alt $(x : A) \rightarrow B$ | $A \rightarrow B$
      \alt $(x : A) \multimap B$ | $A \multimap B$
      \alt $\lambda x. n$ | $m\ n$

      <values> ::= $\U$ | $\L$ | $x$
      \alt $(x : A) \rightarrow B$ | $A \rightarrow B$
      \alt $(x : A) \multimap B$ | $A \multimap B$
      \alt $\lambda x. n$
    \end{grammar}
  \end{figure}

  \begin{figure}[h]
    \caption{Structural Judgments}
    \begin{mathpar}
      \inferrule
      { }
      { \cdot\ ; \cdot \ok }

      \inferrule
      { \Gamma ; \Delta\ \ok \\ \Gamma ; \Delta \vdash A : \U }
      { \Gamma, x : A ; \Delta\ \ok }

      \inferrule
      { \Gamma ; \Delta\ \ok \\ \Gamma ; \Delta \vdash A : \L }
      { \Gamma ; \Delta, x : A\ \ok } 

    \end{mathpar}
  \end{figure}


  \begin{figure}[h]
    \caption{Type Formation} 
    \begin{mathpar}
      \inferrule
      { }
      { \Gamma ; \cdot \vdash \U : \U } 

      \inferrule
      { }
      { \Gamma ; \cdot \vdash \L : \U } 

      \inferrule
      { \Gamma ; \cdot \vdash A : \U }
      { \Gamma ; \cdot \vdash A\ \type }

      \inferrule
      { \Gamma ; \cdot \vdash A : \L }
      { \Gamma ; \cdot \vdash A\ \type }
      \\

      \inferrule
      { \Gamma ; \cdot \vdash A : \U \\ \Gamma, x : A ; \cdot \vdash B\ \type }
      { \Gamma ; \cdot \vdash (x : A) \rightarrow B : \U } 

      \inferrule
      { \Gamma ; \cdot \vdash A : \L \\ \Gamma ; \cdot \vdash B\ \type }
      { \Gamma ; \cdot \vdash A \rightarrow B : \U } 
      \\

      \inferrule
      { \Gamma ; \cdot \vdash A : \U \\ \Gamma, x : A ; \cdot \vdash B\ \type }
      { \Gamma ; \cdot \vdash (x : A) \multimap B : \L } 

      \inferrule
      { \Gamma ; \cdot \vdash A : \L \\ \Gamma ; \cdot \vdash B\ \type }
      { \Gamma ; \cdot \vdash A \multimap B : \L } 
    \end{mathpar}
  \end{figure}

  \begin{figure}[h]
    \caption{Term Formation}
    \begin{mathpar}
      \inferrule
      { }
      { \Gamma, x : A ; \cdot \vdash x : A } 

      \inferrule
      { }
      { \Gamma ; x : A \vdash x : A } 

      \inferrule
      { \Gamma ; \Delta \vdash m : A \\ \Gamma ; \Delta \vdash A \equiv B }
      { \Gamma ; \Delta \vdash m : B } 
      \\

      \inferrule
      { \Gamma ; \cdot \vdash (x : A) \rightarrow B : \U \\ 
        \Gamma, x : A ; \cdot \vdash n : B }
      { \Gamma ; \cdot \vdash \lambda x . n : (x : A) \rightarrow B }

      \inferrule
      { \Gamma ; \cdot \vdash A \rightarrow B : \U \\
        \Gamma ; x : A \vdash n : B }
      { \Gamma ; \cdot \vdash \lambda x . n : A \rightarrow B }
      \\

      \inferrule
      { \Gamma ; \cdot \vdash (x : A) \multimap B : \L \\ 
        \Gamma, x : A ; \Delta \vdash n : B }
      { \Gamma ; \Delta \vdash \lambda x . n : (x : A) \multimap B }

      \inferrule
      { \Gamma ; \cdot \vdash A \multimap B : \L \\ 
        \Gamma ; \Delta, x : A \vdash n : B }
      { \Gamma ; \Delta \vdash \lambda x . n : A \multimap B }
      \\

      \inferrule
      { \Gamma ; \Delta_1 \vdash m : (x : A) \rightarrow B \\
        \Gamma ; \Delta_2 \vdash n : A }
      { \Gamma; \Delta_1, \Delta_2 : m\ n : [n/x]B }

      \inferrule
      { \Gamma ; \Delta_1 \vdash m : A \rightarrow B \\
        \Gamma ; \Delta_2 \vdash n : A }
      { \Gamma; \Delta_1, \Delta_2 : m\ n : B }
      \\

      \inferrule
      { \Gamma ; \Delta_1 \vdash m : (x : A) \multimap B \\
        \Gamma ; \Delta_2 \vdash n : A }
      { \Gamma; \Delta_1, \Delta_2 : m\ n : [n/x]B }

      \inferrule
      { \Gamma ; \Delta_1 \vdash m : A \multimap B \\
        \Gamma ; \Delta_2 \vdash n : A }
      { \Gamma; \Delta_1, \Delta_2 : m\ n : B }
    \end{mathpar}
  \end{figure}

  \begin{figure}[h]
    \caption{Equality}
    \begin{mathpar}
      \inferrule
      { \Gamma ; \Delta \vdash m_1 : A \\ \Gamma ; \Delta \vdash m_2 : A \\ 
        m_1 \pstep^* n \\ m_2 \pstep^* n }
      { \Gamma ; \Delta \vdash m_1 \equiv m_2 }
    \end{mathpar}
  \end{figure}

  \begin{figure}[h]
    \caption{Parallel Reduction}
    \begin{mathpar}
      \inferrule
      { }
      { n \pstep n }

      \inferrule
      { n \pstep n' }
      { \lambda x.n \pstep \lambda x.n' }

      \inferrule
      { m \pstep m' \\ n \pstep n' }
      { m\ n \pstep m'\ n' }

      \inferrule
      { n \pstep n' \\ v \pstep v' }
      { (\lambda x.n)\ v \pstep [v'/x]n' }
      \\

      \inferrule
      { A \pstep A' \\ B \pstep B' }
      { (x : A) \rightarrow B \pstep (x : A') \rightarrow B' }

      \inferrule
      { A \pstep A' \\ B \pstep B' }
      { A \rightarrow B \pstep A' \rightarrow B' }
      \\

      \inferrule
      { A \pstep A' \\ B \pstep B' }
      { (x : A) \multimap B \pstep (x : A') \multimap B' }

      \inferrule
      { A \pstep A' \\ B \pstep B' }
      { A \multimap B \pstep A' \multimap B' }
    \end{mathpar}
  \end{figure}

\end{document}